<?php namespace QuackCompiler\Intl{ class Localization{private static $messages=null;public static function message($key,$arguments){if(null ===static::$messages){static::$messages=['SCO010' => 'Duplicated parameter `%s\' in anonymous function','SCO020' => 'Use of undefined variable `%s\'','SCO030' => '===DELETED===','SCO040' => '===DELETED===','SCO050' => 'Duplicated object property `%s\'','SCO060' => 'Duplicated parameter `%s\' in function `%s\'','SCO070' => 'Symbol `%s\' is not a variable','SCO080' => 'Symbol `%s\' is immutable','SCO090' => 'Invalid left-hand side in assignment','SCO100' => 'Array destructuring expects all children to be names','SCO110' => '===DELETED===','SCO120' => 'Duplicated declaration of `%s\' on where clause','SCO130' => 'Symbol `%s\' declared twice','SCO140' => 'Called %s outside a loop','SCO150' => 'Called %s with undefined label `%s\'','SCO160' => 'Called %s with invalid label `%s\'','SCO170' => 'Duplicated declaration of `%s\' for enum `%s\'','SCO180' => 'Same variable name `%s\' for key and value on foreach','SCO190' => '%s `%s\' not found in implementation','SCO200' => '`%s\' is not a class in implementation','SCO210' => '===DELETED===','SCO220' => '===DELETED===','TYP010' => 'Value passed to while loop should be a `boolean\', not a `%s\'','TYP020' => 'Cannot add element of type `%s\' to array of `%s\'','TYP030' => 'The type of post conditional statement should be a `boolean\', not a `%s\'','TYP040' => 'Expected index of array to be a number. Got `%s\'','TYP050' => 'Expected index of map to be a `%s\'. Got `%s\'','TYP060' => 'Trying to access by index an element of type `%s\' that is not accessible','TYP070' => 'Key on index %d of map expected to be `%s\'. Got `%s\'','TYP080' => 'Value on index %s of map expected to be `%s\'. Got `%s\'','TYP090' => 'Expression of type `%s\' has no property `%s\'','TYP100' => 'Trying to set value of type `%s` to %s','TYP110' => 'No type overload found for operator `%s\' at {%s %s %s}','TYP120' => '===DELETED===','TYP130' => 'Why in the world are you trying to compare two expressions of different types? at {%s %s %s}','TYP140' => 'Value passed to if statement should a `boolean\', not a `%s\'','TYP150' => 'Expecting type of case of switch statement to be `%s\'. Got `%s\'','TYP160' => 'More than one else clause for switch statement','TYP170' => 'Expecting type of field `%s\' of foreach statement to be a `number\'. Got `%s\'','TYP180' => 'Condition passed to elif statement should be a `boolean\', not a `%s\'','TYP190' => 'Cannot infer type of non-variable `%s\'','TYP200' => 'Expected condition %d of when expression to be a `boolean\'. Got `%s\'','TYP210' => 'All results to when expression must be of same type `%s\', but result %d is `%s\'','TYP220' => 'Expected a `number\' on operand `%s\' of range expression. Got `%s\'','TYP230' => 'No type overload for operator `%s\' on type `%s\'','TYP240' => 'Condition of ternary operator should de `boolean\'. Got `%s\'','TYP250' => 'Both sides of ternary expression must have the same type. Got `%s\' and `%s\'','TYP260' => '`%s\' is not iterable','TYP270' => 'You forgot to set a value for immutable variable `%s\', my love','TYP280' => '===DELETED===','TYP290' => 'Caught declaration of free variable `%s\'','TYP300' => 'Cannot assign to variable `%s\' of type `%s\' a value of type `%s\'','TYP310' => 'I\'m sorry, but type `%s\' is not callable','TYP320' => 'Function of type `%s\' expected %d arguments, but received %d','TYP330' => 'Argument number %d of call expected to be a `%s\', but it is a `%s\'','TYP340' => 'On map, cannot match the type of %s `%s\' with `%s\'','TYP350' => 'Bad equation: `%s\' and `%s\', because:
','TYP360' => 'Functions have different number of arguments. One has %d, the other has %d','TYP370' => 'Parameter number %d of function needs to be a `%s\', but it is a `%s\'','TYP380' => 'I was expecting to have a function with return type of `%s\', but you gave me a `%s\'','TYP390' => 'Cannot merge type `%s\' with `%s\', I\'m sorry','TYP400' => 'Ambiguous type for `%s\' & `%s\' because:
     > `%s\' can be either `%s\' or `%s\'','TYP410' => 'A JSX child should be a component or a string, but you gave me `%s\' and I\'m very sad about that'];} return sprintf(...array_merge([static::$messages[$key]],$arguments));}}} namespace QuackCompiler\Lexer{ use \ReflectionClass;abstract class Lexer{const EOF=-1;const EOF_TYPE=0;public $input;public $position=0;public $peek;protected $words=[];public $keywords=[];public function __construct($input){$this->size=strlen($input);if($this->size ===0){exit;} $this->input=$input;$this->peek=$input[0];$this->reserve(new Word(Tag::T_TRUE,'true'));$this->reserve(new Word(Tag::T_FALSE,'false'));$this->reserve(new Word(Tag::T_LET,'let'));$this->reserve(new Word(Tag::T_IF,'if'));$this->reserve(new Word(Tag::T_FOR,'for'));$this->reserve(new Word(Tag::T_WHILE,'while'));$this->reserve(new Word(Tag::T_DO,'do'));$this->reserve(new Word(Tag::T_FOREACH,'foreach'));$this->reserve(new Word(Tag::T_IN,'in'));$this->reserve(new Word(Tag::T_MOD,'mod'));$this->reserve(new Word(Tag::T_WHERE,'where'));$this->reserve(new Word(Tag::T_NIL,'nil'));$this->reserve(new Word(Tag::T_CONTINUE,'continue'));$this->reserve(new Word(Tag::T_SWITCH,'switch'));$this->reserve(new Word(Tag::T_BREAK,'break'));$this->reserve(new Word(Tag::T_AND,'and'));$this->reserve(new Word(Tag::T_OR,'or'));$this->reserve(new Word(Tag::T_XOR,'xor'));$this->reserve(new Word(Tag::T_TRY,'try'));$this->reserve(new Word(Tag::T_RESCUE,'rescue'));$this->reserve(new Word(Tag::T_FINALLY,'finally'));$this->reserve(new Word(Tag::T_RAISE,'raise'));$this->reserve(new Word(Tag::T_ELIF,'elif'));$this->reserve(new Word(Tag::T_ELSE,'else'));$this->reserve(new Word(Tag::T_CASE,'case'));$this->reserve(new Word(Tag::T_NOT,'not'));$this->reserve(new Word(Tag::T_FN,'fn'));$this->reserve(new Word(Tag::T_THEN,'then'));$this->reserve(new Word(Tag::T_BEGIN,'begin'));$this->reserve(new Word(Tag::T_END,'end'));$this->reserve(new Word(Tag::T_FROM,'from'));$this->reserve(new Word(Tag::T_TO,'to'));$this->reserve(new Word(Tag::T_BY,'by'));$this->reserve(new Word(Tag::T_WHEN,'when'));$this->reserve(new Word(Tag::T_UNLESS,'unless'));$this->reserve(new Word(Tag::T_MUT,'mut'));} private function reserve(Word $t){$this->keywords[$t->getTag()]=$t->lexeme;$this->words[$t->lexeme]=$t;} protected function isEnd(){return $this->position >=$this->size;} public function rewind(){if($this->size ===0){exit;} $this->position=0;$this->peek=$this->input[0];} public function consume($n=1){$this->position +=$n;$this->peek=$this->isEnd() ?self::EOF :$this->input[$this->position];} public function stepback($n=1){$pos=$this->position - $n;$this->position=max($pos,0);$this->peek=$this->input[$this->position];} public function preview($n=1){$next=$this->position + $n;return $next >=$this->size ?self::EOF :$this->input[$next];} public function previous(){$previous=$this->position - 1;return $previous < 0 ?null :$this->input[$previous];} public function matches($string){$len=strlen($string);for($i=0;$i < $len;$i++){if($this->preview($i) !==$string[$i]){return false;}} return true;} protected function getWord($word){return isset($this->words[$word]) ?$this->words[$word] :null;} public function is($symbol){return $this->peek ===$symbol;} abstract public function nextToken();}class Token{private $tag;private $content;public $metadata=[];public function __construct($tag,$content=null){$this->tag=$tag;$this->content=$content;} public function getTag(){return $this->tag;} public function getContent(){return $this->content;} public function __toString(){if(!is_null($this->content)){$tag_name=Tag::getName($this->tag);return "[" .$tag_name .", " .$this->content ."]";} return "[" .$this->tag ."]";}}class Tag{const T_IDENT=253;const T_INT_BIN=255;const T_INT_OCT=256;const T_INT_HEX=257;const T_INTEGER=258;const T_DOUBLE=400;const T_DOUBLE_EXP=401;const T_STRING=600;const T_ATOM=601;const T_REGEX=1001;const T_TRUE=260;const T_FALSE=261;const T_IF=262;const T_FOR=263;const T_WHILE=264;const T_DO=265;const T_NIL=272;const T_LET=273;const T_WHERE=280;const T_FOREACH=281;const T_IN=284;const T_AS=504;const T_CONTINUE=508;const T_SWITCH=509;const T_BREAK=510;const T_AND=511;const T_OR=512;const T_XOR=513;const T_TRY=515;const T_RESCUE=516;const T_FINALLY=517;const T_RAISE=518;const T_ELIF=520;const T_ELSE=521;const T_CASE=522;const T_MOD=292;const T_NOT=293;const T_FN=294;const T_THEN=300;const T_BEGIN=301;const T_END=302;const T_FROM=303;const T_TO=304;const T_BY=305;const T_WHEN=306;const T_UNLESS=307;const T_MUT=308;public static function getOperatorLexeme($op){switch($op){case Tag::T_NOT:return 'not';case Tag::T_AND:return 'and';case Tag::T_OR:return 'or';case Tag::T_MOD:return 'mod';case Tag::T_XOR:return 'xor';default:return $op;}} public static function & getPartialOperators(){static $op_table=[ '+','-','*','/','**',Tag::T_MOD,Tag::T_XOR,Tag::T_AND,Tag::T_OR,'<','>','<=','>=','=','<>','=~','<<','>>','~','|','&','|>','.','??','++',];return $op_table;} public static function getName($tag){$token_name=array_search($tag,(new ReflectionClass(__CLASS__))->getConstants(),true);return false ===$token_name ?$tag :$token_name;}}class SymbolDecypher{public static function __callStatic($method,$args){$context=&$args[0];switch($method){case '<':return static::tryMatch($context,['<<','<>','<=','</']);case '>':return static::tryMatch($context,['>>','>=','>>']);case ':':return static::tryMatch($context,['::',':-']);case '*':return static::tryMatch($context,['**']);case '=':return static::tryMatch($context,['=~']);case '|':return static::tryMatch($context,['|>']);case '-':return static::tryMatch($context,['->']);case '&':return static::tryMatch($context,['&{','&(']);case '.':return static::tryMatch($context,['..']);case '#':return static::tryMatch($context,['#{','#(']);case '%':return static::tryMatch($context,['%{']);case '/':return static::tryMatch($context,['/>']);default:return static::fetch($context,$context->peek);}} private static function tryMatch(&$context,$operator_list){foreach($operator_list as $operator){if($context->matches($operator)){return static::fetch($context,$operator);}} return static::fetch($context,$context->peek);} private static function fetch($context,$symbol){$size=strlen($symbol);$context->consume($size);$context->column +=$size;return new Token($symbol);}}class Tokenizer extends Lexer{public $line=1;public $column=0;public function __construct($input){parent::__construct($input);} public function nextToken(){while($this->peek !=self::EOF){if(ctype_digit($this->peek)){return $this->digit();} if((ctype_alpha($this->peek) || $this->is('_')) ||($this->is('_') && ctype_alnum((string) $this->preview()))){return $this->identifier();} if(ctype_space($this->peek)){$this->space();continue;} if($this->matches('@') &&(ctype_alpha($this->preview()) || '_' ===$this->preview())){return $this->atom();} if($this->matches('--') || $this->matches('#!')){$this->singlelineComment();continue;} if($this->matches('{-')){$this->multilineComment();continue;} if($this->is('"') || $this->is("'")){return $this->string($this->peek);} if($this->matches('&/')){return $this->regex();}  return SymbolDecypher::{$this->peek}($this);} return new Token(self::EOF_TYPE);} public function digit(){$buffer=[];$number=$this->readChar();if(!$this->isEnd() && $number ==='0' && ctype_xdigit($this->preview())){$tag=Tag::T_INT_HEX;$found=false;if($this->peek ==='x'){$found=true;$buffer[]=$number;do{$buffer[]=$this->readChar();} while(ctype_xdigit($this->peek));} else{$bits=0;if(ctype_digit($this->preview())){if($this->peek ==='b'){$bits=1;$tag=Tag::T_INT_BIN;$found=true;} else if($this->peek ==='o'){$bits=3;$tag=Tag::T_INT_OCT;$found=true;} if($found){$buffer[]=$number;do{$buffer[]=$this->readChar();} while(ctype_digit($this->peek) && !((int) $this->peek >> $bits));if(ctype_alpha(end($buffer))){$found=false;$buffer=[];$this->stepback();}}}} if($found){$value=implode($buffer);$this->column +=sizeof($buffer);return new Token($tag,$value);}} $tag=Tag::T_INTEGER;$buffer[]=$number;$buffer=array_merge($buffer,$this->integer());if(!$this->isEnd() && $this->peek ==='.' && ctype_digit($this->preview())){$tag=Tag::T_DOUBLE;$buffer[]=$this->readChar();$buffer=array_merge($buffer,$this->integer());}  if(!$this->isEnd() && $this->is('e')){if(ctype_digit($this->preview())){$tag=Tag::T_DOUBLE_EXP;$buffer[]=$this->readChar();$buffer=array_merge($buffer,$this->integer());} else if(($this->preview() ==='+' || $this->preview() ==='-') && ctype_digit($this->preview(2))){$tag=Tag::T_DOUBLE_EXP;$buffer[]=$this->readChar();$buffer[]=$this->readChar();$buffer=array_merge($buffer,$this->integer());}} $value=implode($buffer);$this->column +=sizeof($buffer);return new Token($tag,$value);} private function integer(){$arr=[];while(!$this->isEnd() && ctype_digit($this->peek)){$arr[]=$this->readChar();} return $arr;} private function identifier(){$buffer=[];do{$buffer[]=$this->readChar();} while(ctype_alnum((string) $this->peek) || $this->peek ==='_');$string=implode($buffer);$word=$this->getWord($string);$this->column +=sizeof($buffer);if($word !==null){return $word;} return new Token(Tag::T_IDENT,$string);} private function space(){$new_line=array_map('ord',["\r","\n","\r\n",PHP_EOL]);do{if(in_array(ord($this->peek),$new_line)){$this->line++;$this->column=1;} else{$this->column++;} $this->consume();} while(ctype_space($this->peek));} private function string($delimiter){$this->consume();$this->column++;$buffer=[];while(!$this->isEnd() && !($this->is($delimiter) && $this->previous() !=='\\')){$buffer[]=$this->readChar();$this->column++;} $string=implode($buffer);if(!$this->isEnd()){$this->consume();$this->column++;} $token=new Token(Tag::T_STRING,$string);$token->metadata['delimiter']=$delimiter;return $token;} private function regex(){$buffer=[];$buffer[]=$this->readChar();$buffer[]=$this->readChar();$this->column +=2;while(!$this->isEnd() && !($this->is('/') && $this->previous() !=='\\')){$buffer[]=$this->readChar();$this->column++;} if(!$this->isEnd()){$buffer[]=$this->readChar();$this->column++;}  $allowed_modifiers=[ 'i','m','s','x','e','A','D','S','U','X','J','u' ];while(!$this->isEnd()){$char=$this->readChar();if(in_array($char,$allowed_modifiers,true)){$buffer[]=$char;$this->column++;} else{$this->column--;$this->stepback();break;}} $regex=implode($buffer);return new Token(Tag::T_REGEX,$regex);} private function singleLineComment(){$newline=array_map('ord',["\r","\n","\r\n",PHP_EOL]);$this->consume(2);while(!$this->isEnd()){$code=ord($this->readChar());$this->column++;if(in_array($code,$newline,true)){$this->line++;break;}}} private function multilineComment(){$newline=array_map('ord',["\r","\n","\r\n",PHP_EOL]);$this->consume(2);while(!$this->isEnd() && !$this->matches('-}')){$code=ord($this->readChar());$this->column++;if(in_array($code,$newline,true)){$this->line++;}} if(!$this->isEnd()){$this->consume(2);$this->column +=2;}} private function atom(){do{$buffer[]=$this->readChar();$this->column++;} while(ctype_alnum((string) $this->peek) || $this->peek ==='_');$atom=implode($buffer);return new Token(Tag::T_ATOM,$atom);} private function readChar(){$char=$this->peek;$this->consume();return $char;} public function eagerlyEvaluate(){$this->rewind();$token_stream=[];while($this->peek !=self::EOF){$token_stream[]=$this->nextToken();} return $token_stream;} public function printTokens(){$this->rewind();$token=$this->nextToken();while($token->getTag() !==static::EOF_TYPE){echo $token;$token=$this->nextToken();}}}class Word extends Token{public $lexeme;public function __construct($tag,$word){parent::__construct($tag);$this->lexeme=(string) $word;} public function __toString(){return "[" .$this->lexeme ."]";}}} namespace QuackCompiler\Parselets{ use \QuackCompiler\Ast\Expr\Expr;use \QuackCompiler\Lexer\Token;use \QuackCompiler\Parser\Grammar;interface InfixParselet{public function parse($parser,$left,Token $token);public function getPrecedence();}interface PrefixParselet{public function parse($parser,Token $token);}trait Parselet{private $prefix=[];private $infix=[];protected function register($tag,$parselet){if($parselet instanceof PrefixParselet){$this->prefix[$tag]=$parselet;} elseif($parselet instanceof InfixParselet){$this->infix[$tag]=$parselet;}} public function infixParseletForToken(Token $token){$key=$token->getTag();return array_key_exists($key,$this->infix) ?$this->infix[$key] :null;} public function prefixParseletForToken(Token $token){$key=$token->getTag();return array_key_exists($key,$this->prefix) ?$this->prefix[$key] :null;} private function getPrecedence(){$parselet=$this->infixParseletForToken($this->reader->lookahead);return !is_null($parselet) ?$parselet->getPrecedence() :0;}}} namespace QuackCompiler\Parselets\Expr{ use \QuackCompiler\Parser\Grammar;use \QuackCompiler\Ast\Expr\ObjectExpr;use \QuackCompiler\Lexer\Token;use \QuackCompiler\Parselets\PrefixParselet;use \QuackCompiler\Parser\Precedence;use \QuackCompiler\Ast\Expr\WhenExpr;use \QuackCompiler\Lexer\Tag;use \QuackCompiler\Ast\Expr\PartialFuncExpr;use \QuackCompiler\Ast\Expr\AccessExpr;use \QuackCompiler\Ast\Expr\Expr;use \QuackCompiler\Parselets\InfixParselet;use \QuackCompiler\Ast\Expr\StringExpr;use \QuackCompiler\Ast\Expr\JSX\JSXElement;use \QuackCompiler\Parser\SyntaxError;use \QuackCompiler\Ast\Expr\LambdaExpr;use \QuackCompiler\Ast\Expr\OperatorExpr;use \QuackCompiler\Ast\Expr\ArrayExpr;use \QuackCompiler\Ast\Expr\TernaryExpr;use \QuackCompiler\Ast\Expr\NameExpr;use \QuackCompiler\Ast\Expr\PrefixExpr;use \QuackCompiler\Ast\Expr\CallExpr;use \QuackCompiler\Ast\Expr\WhereExpr;use \QuackCompiler\Ast\Expr\NumberExpr;use \QuackCompiler\Ast\Expr\AtomExpr;use \QuackCompiler\Ast\Expr\NilExpr;use \QuackCompiler\Ast\Expr\BoolExpr;use \QuackCompiler\Ast\Expr\RegexExpr;use \QuackCompiler\Ast\Expr\MapExpr;use \QuackCompiler\Ast\Expr\PostfixExpr;use \QuackCompiler\Ast\Expr\RangeExpr;use \QuackCompiler\Ast\Expr\BlockExpr;use \QuackCompiler\Ast\Stmt\StmtList;class ObjectParselet implements PrefixParselet{public function parse($grammar,Token $token){$keys=[];$values=[];if(!$grammar->reader->consumeIf('}')){$keys[]=$grammar->name_parser->_identifier();$grammar->reader->match(':');$values[]=$grammar->_expr();while($grammar->reader->consumeIf(',')){$keys[]=$grammar->name_parser->_identifier();$grammar->reader->match(':');$values[]=$grammar->_expr();} $grammar->reader->match('}');} return new ObjectExpr($keys,$values);}}class WhenParselet implements PrefixParselet{public function parse($grammar,Token $token){$cases=[];$default=null;do{if(null ===$default && $grammar->reader->is(Tag::T_ELSE)){$grammar->reader->consume();$default=new \stdClass;$default->condition=null;$default->action=$grammar->_expr();$cases[]=$default;} else{$case=new \stdClass;$case->condition=$grammar->_expr();$grammar->reader->match('->');$case->action=$grammar->_expr();$cases[]=$case;} if(!$grammar->reader->is(Tag::T_END)){$grammar->reader->match(',');} else{break;}} while(true);$grammar->reader->match(Tag::T_END);return new WhenExpr($cases);}}class GroupParselet implements PrefixParselet{public function parse($grammar,Token $token){$expr=$grammar->_expr();$expr->addParentheses();$grammar->reader->match(')');return $expr;}}class PartialFuncParselet implements PrefixParselet{public function parse($grammar,Token $token){$op_table=&Tag::getPartialOperators();$next_op=$grammar->reader->lookahead->getTag();$right=null;if(in_array($next_op,$op_table,true)){$grammar->reader->match($next_op);if(!$grammar->reader->is(')')){$right=$grammar->_expr();} $grammar->reader->match(')');} else{$grammar->reader->match('operator');} return new PartialFuncExpr($next_op,$right);}}class AccessParselet implements InfixParselet{public function parse($grammar,$left,Token $token){$index=$grammar->_expr();$grammar->reader->match('}');return new AccessExpr($left,$index);} public function getPrecedence(){return Precedence::ACCESS;}}class JSXParselet implements PrefixParselet{private $grammar;private $reader;private $name_parser;public function parse($grammar,Token $token){$this->grammar=$grammar;$this->reader=$grammar->reader;$this->name_parser=$grammar->name_parser;return $this->JSXElement(true);} public function JSXElement($partial=false){if(!$partial){$this->reader->match('<');} $name=$this->name_parser->_identifier();$attributes=[];while(!$this->reader->is('/>') && !$this->reader->is('>')){$attributes[]=$this->JSXAttribute();} if($this->reader->consumeIf('/>')){return new JSXElement($name,$attributes,null);} $this->reader->match('>');$children=[];while(!$this->reader->is('</')){$children[]=$this->JSXChild();} $this->reader->match('</');$closing_tag=$this->name_parser->_identifier();if($name !==$closing_tag){throw new SyntaxError([ 'expected' => "</{$name}>",'found' => $this->reader->lookahead,'parser' => $this->reader ]);} $this->reader->match('>');return new JSXElement($name,$attributes,$children);} public function JSXChild(){if($this->reader->is('<')){return $this->JSXElement();} $this->reader->match('{');$expr=$this->grammar->_expr();$this->reader->match('}');return $expr;} public function JSXAttribute(){$name=$this->name_parser->_identifier();if(!$this->reader->consumeIf(':')){return [$name];} if($this->reader->is(Tag::T_STRING)){$token=$this->reader->lookahead;$content=$this->reader->consume();return [$name,new StringExpr($content,$token->metadata['delimiter'])];} $this->reader->match('{');$value=$this->grammar->_expr();$this->reader->match('}');return [$name,$value];}}class LambdaParselet implements PrefixParselet{const TYPE_EXPRESSION=0x1;const TYPE_STATEMENT=0x2;public function parse($grammar,Token $token){$parameters=[];$kind=null;$body=null;$has_brackets=false;if($grammar->reader->is(Tag::T_IDENT)){$name=$grammar->name_parser->_identifier();$parameters[]=(object) [ 'name' => $name,'type' => null ];} else{$has_brackets=true;$grammar->reader->match('[');if(!$grammar->reader->consumeIf(']')){$parameters[]=$grammar->stmt_parser->_parameter();while($grammar->reader->consumeIf(',')){$parameters[]=$grammar->stmt_parser->_parameter();} $grammar->reader->match(']');}} $grammar->reader->match('->');if($grammar->reader->is(Tag::T_BEGIN)){$kind=static::TYPE_STATEMENT;$grammar->reader->consume();$body=iterator_to_array($grammar->stmt_parser->_innerStmtList());$grammar->reader->match(Tag::T_END);} else{$kind=static::TYPE_EXPRESSION;$body=$grammar->_expr();} return new LambdaExpr($parameters,$kind,$body,$has_brackets);}}class BinaryOperatorParselet implements InfixParselet{public $precedence;public $is_right;public function __construct($precedence,$is_right){$this->precedence=$precedence;$this->is_right=$is_right;} public function parse($grammar,$left,Token $token){$right=$grammar->_expr($this->precedence - (int) $this->is_right);return new OperatorExpr($left,$token->getTag(),$right);} public function getPrecedence(){return $this->precedence;}}class ArrayParselet implements PrefixParselet{public function parse($grammar,Token $token){$items=[];if($grammar->reader->is('}')){$grammar->reader->consume();} else{$items[]=$grammar->_expr();while($grammar->reader->is(',')){$grammar->reader->consume();$items[]=$grammar->_expr();} $grammar->reader->match('}');} return new ArrayExpr($items);}}class MemberAccessParselet implements InfixParselet{public function parse($grammar,$left,Token $token){$right=$grammar->name_parser->_identifier();return new OperatorExpr($left,$token->getTag(),$right);} public function getPrecedence(){return Precedence::MEMBER_ACCESS;}}class PrefixOperatorParselet implements PrefixParselet{public function parse($parser,Token $token){$operand=$parser->_expr(Precedence::PREFIX);return new PrefixExpr($token,$operand);}}class CallParselet implements InfixParselet{public function parse($grammar,$left,Token $token){$args=[];if(!$grammar->reader->is(')')){$args[]=$grammar->_expr();while($grammar->reader->is(',')){$grammar->reader->consume();$args[]=$grammar->_expr();}} $grammar->reader->match(')');return new CallExpr($left,$args);} public function getPrecedence(){return Precedence::CALL;}}class WhereParselet implements InfixParselet{public function parse($grammar,$left,Token $token){$clauses=[];$name=$grammar->name_parser->_identifier();$grammar->reader->match(':-');$value=$grammar->_expr();$clauses[]=[$name,$value];while($grammar->reader->is(',')){$grammar->reader->consume();$name=$grammar->name_parser->_identifier();$grammar->reader->match(':-');$value=$grammar->_expr();$clauses[]=[$name,$value];} return new WhereExpr($left,$clauses);} public function getPrecedence(){return Precedence::WHERE;}}class LiteralParselet implements PrefixParselet{public function parse($grammar,Token $token){$tag=$token->getTag();$content=$token->getContent();switch($tag){case Tag::T_ATOM:return new AtomExpr($content);case Tag::T_STRING:return new StringExpr($content,$token->metadata['delimiter']);case Tag::T_DOUBLE:case Tag::T_INTEGER:return new NumberExpr($content,$tag ===Tag::T_DOUBLE ?'double' :'int');case Tag::T_INT_HEX:return new NumberExpr($content,'int','hexadec');case Tag::T_INT_OCT:return new NumberExpr($content,'int','octal');case Tag::T_INT_BIN:return new NumberExpr($content,'int','binary');case Tag::T_DOUBLE_EXP:return new NumberExpr($content,'double','scientific');case Tag::T_NIL:return new NilExpr();case Tag::T_TRUE:case Tag::T_FALSE:return new BoolExpr($tag ===Tag::T_TRUE);case Tag::T_REGEX:return new RegexExpr($content);}}}class MapParselet implements PrefixParselet{public function parse($grammar,Token $token){$keys=[];$values=[];if($grammar->reader->is('}')){$grammar->reader->consume();} else{$keys[]=$grammar->_expr();$grammar->reader->match(':');$values[]=$grammar->_expr();while($grammar->reader->is(',')){$grammar->reader->consume();$keys[]=$grammar->_expr();$grammar->reader->match(':');$values[]=$grammar->_expr();} $grammar->reader->match('}');} return new MapExpr($keys,$values);}}class PostfixOperatorParselet implements InfixParselet{public $precedence;public function __construct($precedence){$this->precedence=$precedence;} public function parse($grammar,$left,Token $token){return new PostfixExpr($left,$token->getTag());} public function getPrecedence(){return $this->precedence;}}class RangeParselet implements InfixParselet{public function parse($grammar,$from,Token $token){$to=$grammar->_expr();$by=null;if($grammar->reader->is(Tag::T_BY)){$grammar->reader->consume();$by=$grammar->_expr();} return new RangeExpr($from,$to,$by);} public function getPrecedence(){return Precedence::RANGE;}}class BlockParselet implements PrefixParselet{public function parse($grammar,Token $token){$body=new StmtList(iterator_to_array($grammar->stmt_parser->_innerStmtList()));$grammar->reader->match('}');return new BlockExpr($body);}}class TernaryParselet implements InfixParselet{public function parse($grammar,$left,Token $token){$then=$grammar->_expr();$grammar->reader->match(Tag::T_ELSE);$else=$grammar->_expr(Precedence::TERNARY - 1);return new TernaryExpr($left,$then,$else);} public function getPrecedence(){return Precedence::TERNARY;}}class NameParselet implements PrefixParselet{public function parse($grammar,Token $token){return new NameExpr($token->getContent());}}} namespace QuackCompiler\Parselets\Types{ use \QuackCompiler\Ast\Types\InstanceType;use \QuackCompiler\Lexer\Token;use \QuackCompiler\Parselets\PrefixParselet;use \QuackCompiler\Ast\Types\ObjectType;use \QuackCompiler\Ast\Types\AtomType;use \QuackCompiler\Lexer\Tag;use \QuackCompiler\Ast\Types\ListType;use \QuackCompiler\Ast\Types\LiteralType;use \QuackCompiler\Ast\Types\GenericType;use \QuackCompiler\Types\NativeQuackType;use \QuackCompiler\Ast\Types\FunctionType;use \QuackCompiler\Ast\Types\TupleType;use \QuackCompiler\Ast\Types\MapType;use \QuackCompiler\Ast\Types\OperatorType;use \QuackCompiler\Parser\TypeParser;use \QuackCompiler\Parselets\InfixParselet;class InstanceTypeParselet implements PrefixParselet{public function parse($grammar,Token $token){$instance=$grammar->name_parser->_qualifiedName();return new InstanceType($instance);}}class ObjectTypeParselet implements PrefixParselet{public function parse($grammar,Token $token){$properties=[];if(!$grammar->reader->is('}')){do{$key=$grammar->name_parser->_identifier();$grammar->reader->match(':');$properties[$key]=$grammar->_type();} while($grammar->reader->consumeIf(','));} $grammar->reader->match('}');return new ObjectType($properties);}}class AtomTypeParselet implements PrefixParselet{public function parse($grammar,Token $token){return new AtomType($token->getContent());}}class ListTypeParselet implements PrefixParselet{public function parse($grammar,Token $token){$type=$grammar->_type();$grammar->reader->match('}');return new ListType($type);}}class LiteralTypeParselet implements PrefixParselet{public function parse($grammar,Token $token){$names=[ 'string' => NativeQuackType::T_STR,'number' => NativeQuackType::T_NUMBER,'boolean' => NativeQuackType::T_BOOL,'regex' => NativeQuackType::T_REGEX,'block' => NativeQuackType::T_BLOCK,'unit' => NativeQuackType::T_UNIT,'byte' => NativeQuackType::T_BYTE,'atom' => NativeQuackType::T_ATOM ];$name=$token->getContent();return array_key_exists($name,$names) ?new LiteralType($names[$name]) :new GenericType($name);}}class FunctionTypeParselet implements PrefixParselet{public function parse($grammar,Token $token){$parameters=[];$return=new LiteralType(NativeQuackType::T_UNIT);if($grammar->reader->is(Tag::T_IDENT)){$parameters[]=$grammar->_type();} else{$grammar->reader->match('[');if(!$grammar->reader->consumeIf(']')){do{$parameters[]=$grammar->_type();} while($grammar->reader->consumeIf(','));$grammar->reader->match(']');}} if($grammar->reader->consumeIf('->')){$return=$grammar->_type();} return new FunctionType($parameters,$return);}}class TupleTypeParselet implements PrefixParselet{public function parse($grammar,Token $token){$types=[];if(!$grammar->reader->consumeIf(')')){do{$types[]=$grammar->_type();} while($grammar->reader->consumeIf(','));$grammar->reader->match(')');} return new TupleType(...$types);}}class MapTypeParselet implements PrefixParselet{public function parse($grammar,Token $token){$key=$grammar->_type();$grammar->reader->match(':');$value=$grammar->_type();$grammar->reader->match('}');return new MapType($key,$value);}}class GroupTypeParselet implements PrefixParselet{public function parse($grammar,Token $token){$type=$grammar->_type();$type->addParentheses();$grammar->reader->match(')');return $type;}}class BinaryOperatorTypeParselet implements InfixParselet{public $precedence;public $is_right;public function __construct($precedence,$is_right){$this->precedence=$precedence;$this->is_right=$is_right;} public function parse($parser,$left,Token $token){$right=$parser->_type($this->precedence - (int) $this->is_right);return new OperatorType($left,$token->getTag(),$right);} public function getPrecedence(){return $this->precedence;}}} namespace QuackCompiler\Parser{ use \Exception;use \QuackCompiler\Lexer\Tag;use \QuackCompiler\Lexer\Token;use \QuackCompiler\Lexer\Tokenizer;use \QuackCompiler\Parselets\Parselet;use \QuackCompiler\Parselets\Expr\BinaryOperatorParselet;use \QuackCompiler\Parselets\Expr\LiteralParselet;use \QuackCompiler\Parselets\Expr\NameParselet;use \QuackCompiler\Parselets\Expr\PostfixOperatorParselet;use \QuackCompiler\Parselets\Expr\PrefixOperatorParselet;use \QuackCompiler\Parselets\Expr\TernaryParselet;use \QuackCompiler\Parselets\Expr\GroupParselet;use \QuackCompiler\Parselets\Expr\LambdaParselet;use \QuackCompiler\Parselets\Expr\ArrayParselet;use \QuackCompiler\Parselets\Expr\MemberAccessParselet;use \QuackCompiler\Parselets\Expr\WhenParselet;use \QuackCompiler\Parselets\Expr\CallParselet;use \QuackCompiler\Parselets\Expr\AccessParselet;use \QuackCompiler\Parselets\Expr\RangeParselet;use \QuackCompiler\Parselets\Expr\PartialFuncParselet;use \QuackCompiler\Parselets\Expr\WhereParselet;use \QuackCompiler\Parselets\Expr\MapParselet;use \QuackCompiler\Parselets\Expr\ObjectParselet;use \QuackCompiler\Parselets\Expr\BlockParselet;use \QuackCompiler\Parselets\Expr\JSXParselet;use \QuackCompiler\Ast\Types\FunctionType;use \QuackCompiler\Ast\Types\GenericType;use \QuackCompiler\Ast\Types\InstanceType;use \QuackCompiler\Ast\Types\ListType;use \QuackCompiler\Ast\Types\LiteralType;use \QuackCompiler\Ast\Types\MapType;use \QuackCompiler\Ast\Types\ObjectType;use \QuackCompiler\Ast\Types\TupleType;use \QuackCompiler\Parselets\Types\AtomTypeParselet;use \QuackCompiler\Parselets\Types\BinaryOperatorTypeParselet;use \QuackCompiler\Parselets\Types\FunctionTypeParselet;use \QuackCompiler\Parselets\Types\GroupTypeParselet;use \QuackCompiler\Parselets\Types\InstanceTypeParselet;use \QuackCompiler\Parselets\Types\ListTypeParselet;use \QuackCompiler\Parselets\Types\LiteralTypeParselet;use \QuackCompiler\Parselets\Types\MapTypeParselet;use \QuackCompiler\Parselets\Types\ObjectTypeParselet;use \QuackCompiler\Parselets\Types\TupleTypeParselet;use \QuackCompiler\Types\NativeQuackType;use \QuackCompiler\Lexer\Word;use \QuackCompiler\Ast\Stmt\FnStmt;use \QuackCompiler\Ast\Stmt\FnSignatureStmt;use \QuackCompiler\Ast\Stmt\ModuleStmt;use \QuackCompiler\Ast\Stmt\StmtList;use \QuackCompiler\Ast\Stmt\BlockStmt;use \QuackCompiler\Ast\Stmt\BreakStmt;use \QuackCompiler\Ast\Stmt\CaseStmt;use \QuackCompiler\Ast\Stmt\ContinueStmt;use \QuackCompiler\Ast\Stmt\ElifStmt;use \QuackCompiler\Ast\Stmt\ExprStmt;use \QuackCompiler\Ast\Stmt\ForeachStmt;use \QuackCompiler\Ast\Stmt\ForStmt;use \QuackCompiler\Ast\Stmt\IfStmt;use \QuackCompiler\Ast\Stmt\LabelStmt;use \QuackCompiler\Ast\Stmt\LetStmt;use \QuackCompiler\Ast\Stmt\PostConditionalStmt;use \QuackCompiler\Ast\Stmt\ProgramStmt;use \QuackCompiler\Ast\Stmt\RaiseStmt;use \QuackCompiler\Ast\Stmt\ReturnStmt;use \QuackCompiler\Ast\Stmt\SwitchStmt;use \QuackCompiler\Ast\Stmt\TryStmt;use \QuackCompiler\Ast\Stmt\WhileStmt;abstract class Parser{use Parselet;public $input;public $lookahead;public $scope_level=0;public function __construct(Tokenizer $input){$this->input=$input;$this->consume();} public function match($tag){$hint=null;if($this->lookahead->getTag() ===$tag){return $this->consume();}    if(Tag::T_IDENT ===$this->lookahead->getTag() && array_key_exists($tag,$this->input->keywords)){$expected_lexeme=$this->input->keywords[$tag];$provided_lexeme=$this->lookahead->getContent();$distance=levenshtein($expected_lexeme,$provided_lexeme);if($distance <=2){$hint="Did you mean \"{$expected_lexeme}\" instead of \"{$provided_lexeme}\"?";}} $params=[ 'expected' => $tag,'found' => $this->lookahead,'parser' => $this,'hint' => $hint ];if(0 ===$this->lookahead->getTag()){throw new EOFError($params);};throw new SyntaxError($params);} public function opt($tag){if($this->lookahead->getTag() ===$tag){$pointer=$this->consume();return $pointer ===null ?true :$pointer;} return false;} public function is($tag){return $this->lookahead->getTag() ===$tag;} public function consume(){$content=$this->lookahead ===null ?:$this->lookahead->getContent();$this->lookahead=$this->input->nextToken();return $content;} public function consumeIf($symbol){if($this->is($symbol)){$this->consume();return true;} return false;} public function consumeAndFetch(){$clone=$this->lookahead;$this->lookahead=$this->input->nextToken();return $clone;} public function position(){return ["line" => $this->input->line,"column" => $this->input->column];} public function openScope(){$this->scope_level++;} public function closeScope(){$this->scope_level--;} public function indent(){return str_repeat('  ',$this->scope_level);} public function dedent(){return str_repeat('  ',max(0,$this->scope_level - 1));}}class TokenChecker{private $reader;public function __construct(TokenReader $reader){$this->reader=$reader;} public function startsInnerStmt(){$possible_inner_stmts=[Tag::T_FN];return in_array($this->reader->lookahead->getTag(),$possible_inner_stmts,true) || $this->startsStmt();} public function startsStmt(){static $possible_stmts=[ Tag::T_IF,Tag::T_LET,Tag::T_WHILE,Tag::T_DO,Tag::T_FOR,Tag::T_FOREACH,Tag::T_SWITCH,Tag::T_TRY,Tag::T_BREAK,Tag::T_CONTINUE,Tag::T_RAISE,Tag::T_BEGIN,'^','[' ];$next_tag=$this->reader->lookahead->getTag();return in_array($next_tag,$possible_stmts,true);} public function isEoF(){return 0 ===$this->reader->lookahead->getTag();}}class ExprParser{use Attachable;use Parselet;public $reader;public function __construct($reader){$this->reader=$reader;$this->register('&(',new PartialFuncParselet);$this->register(Tag::T_INTEGER,new LiteralParselet);$this->register(Tag::T_INT_HEX,new LiteralParselet);$this->register(Tag::T_INT_OCT,new LiteralParselet);$this->register(Tag::T_INT_BIN,new LiteralParselet);$this->register(Tag::T_DOUBLE,new LiteralParselet);$this->register(Tag::T_DOUBLE_EXP,new LiteralParselet);$this->register(Tag::T_STRING,new LiteralParselet);$this->register(Tag::T_REGEX,new LiteralParselet);$this->register(Tag::T_IDENT,new NameParselet);$this->register(Tag::T_THEN,new TernaryParselet);$this->register('..',new RangeParselet);$this->register('(',new GroupParselet);$this->register('(',new CallParselet);$this->register('{',new ArrayParselet);$this->register('{',new AccessParselet);$this->register('%{',new ObjectParselet);$this->register('#{',new MapParselet);$this->register('&{',new BlockParselet);$this->register('&',new LambdaParselet);$this->register('.',new MemberAccessParselet);$this->register(Tag::T_TRUE,new LiteralParselet);$this->register(Tag::T_FALSE,new LiteralParselet);$this->register(Tag::T_NIL,new LiteralParselet);$this->register(Tag::T_ATOM,new LiteralParselet);$this->register(Tag::T_WHEN,new WhenParselet);$this->register(Tag::T_WHERE,new WhereParselet);$this->prefix('+');$this->prefix('-');$this->prefix('^^');$this->prefix('*');$this->prefix('~');$this->prefix(Tag::T_NOT);$this->infixLeft('+',Precedence::ADDITIVE);$this->infixLeft('-',Precedence::ADDITIVE);$this->infixLeft('*',Precedence::MULTIPLICATIVE);$this->infixLeft('/',Precedence::MULTIPLICATIVE);$this->infixLeft(Tag::T_MOD,Precedence::MULTIPLICATIVE);$this->infixLeft(Tag::T_AND,Precedence::LOGICAL_AND);$this->infixLeft(Tag::T_OR,Precedence::LOGICAL_OR);$this->infixLeft(Tag::T_XOR,Precedence::LOGICAL_XOR);$this->infixLeft('|',Precedence::BITWISE_OR);$this->infixLeft('&',Precedence::BITWISE_AND);$this->infixLeft('^',Precedence::BITWISE_XOR);$this->infixLeft('<<',Precedence::BITWISE_SHIFT);$this->infixLeft('>>',Precedence::BITWISE_SHIFT);$this->infixLeft('=',Precedence::VALUE_COMPARATOR);$this->infixLeft('=~',Precedence::VALUE_COMPARATOR);$this->infixLeft('<>',Precedence::VALUE_COMPARATOR);$this->infixLeft('<=',Precedence::SIZE_COMPARATOR);$this->infixLeft('<',Precedence::SIZE_COMPARATOR);$this->infixLeft('>=',Precedence::SIZE_COMPARATOR);$this->infixLeft('>',Precedence::SIZE_COMPARATOR);$this->infixLeft('|>',Precedence::PIPELINE);$this->infixLeft('??',Precedence::COALESCENCE);$this->infixRight('**',Precedence::EXPONENT);$this->infixRight(':-',Precedence::ASSIGNMENT);$this->register('<',new JSXParselet);} public function _expr($precedence=0,$opt=false){$token=$this->reader->lookahead;$prefix=$this->prefixParseletForToken($token);if(is_null($prefix)){if(!$opt){throw new SyntaxError([ 'expected' => 'expression','found' => $token,'parser' => $this->reader ]);} return null;}   $this->reader->consume();$left=$prefix->parse($this,$token);while($precedence < $this->getPrecedence()){$token=$this->reader->consumeAndFetch();$infix=$this->infixParseletForToken($token);$left=$infix->parse($this,$left,$token);} return $left;} private function postfix($tag,$precedence){$this->register($tag,new PostfixOperatorParselet($precedence));} private function prefix($tag){$this->register($tag,new PrefixOperatorParselet());} private function infixLeft($tag,$precedence){$this->register($tag,new BinaryOperatorParselet($precedence,false));} private function infixRight($tag,$precedence){$this->register($tag,new BinaryOperatorParselet($precedence,true));} public function _optExpr(){return $this->_expr(0,true);}}class TypeParser{use Attachable;use Parselet;public $parser;public function __construct(Parser $parser){$this->reader=$parser;$this->register('(',new GroupTypeParselet);$this->register(Tag::T_ATOM,new AtomTypeParselet);$this->register(Tag::T_IDENT,new LiteralTypeParselet);$this->register('{',new ListTypeParselet);$this->register('#{',new MapTypeParselet);$this->register('#(',new TupleTypeParselet);$this->register('%',new InstanceTypeParselet);$this->register('%{',new ObjectTypeParselet);$this->register('&',new FunctionTypeParselet);$this->register('|',new BinaryOperatorTypeParselet(Precedence::UNION_TYPE,false));$this->register('&',new BinaryOperatorTypeParselet(Precedence::INTERSECTION_TYPE,false));} public function _type($precedence=0){$token=$this->reader->lookahead;$prefix=$this->prefixParseletForToken($token);if(is_null($prefix)){throw new SyntaxError([ 'expected' => 'type signature','found' => $token,'parser' => $this->reader ]);} $this->reader->consume();$left=$prefix->parse($this,$token);while($precedence < $this->getPrecedence()){$token=$this->reader->consumeAndFetch();$infix=$this->infixParseletForToken($token);$left=$infix->parse($this,$left,$token);} return $left;}}class EOFError extends SyntaxError{public function __construct($parameters){parent::__construct($parameters);} protected function getFoundTokenName(){return "end of the source";}}class NameParser{use Attachable;public $reader;public function __construct($reader){$this->reader=$reader;} public function _identifier(){return $this->reader->match(Tag::T_IDENT);} public function _qualifiedName(){$names=[];do{$names[]=$this->_identifier();} while($this->reader->consumeIf('.'));return $names;}}class Precedence{const ASSIGNMENT=1;const WHERE=2;const PIPELINE=3;const MEMBER_ACCESS=4;const TERNARY=5;const COALESCENCE=6;const RANGE=7;const LOGICAL_OR=8;const LOGICAL_XOR=9;const LOGICAL_AND=10;const BITWISE_OR=11;const BITWISE_XOR=12;const BITWISE_AND=13;const VALUE_COMPARATOR=14;const SIZE_COMPARATOR=15;const BITWISE_SHIFT=16;const ADDITIVE=17;const MULTIPLICATIVE=18;const PREFIX=19;const POSTFIX=20;const TYPE_CAST=21;const EXPONENT=22;const CALL=23;const ACCESS=24;const UNION_TYPE=1;const INTERSECTION_TYPE=2;}class TokenReader extends Parser{private $main;public $ast=[];public $grammar;public function __construct(Tokenizer $input){parent::__construct($input);$name_parser=new NameParser($this);$type_parser=new TypeParser($this);$expr_parser=new ExprParser($this);$decl_parser=new DeclParser($this);$stmt_parser=new StmtParser($this);$type_parser->attachParsers([ 'name_parser' => $name_parser ]);$expr_parser->attachParsers([ 'name_parser' => $name_parser,'stmt_parser' => $stmt_parser ]);$decl_parser->attachParsers([ 'name_parser' => $name_parser,'expr_parser' => $expr_parser,'stmt_parser' => $stmt_parser,'type_parser' => $type_parser ]);$stmt_parser->attachParsers([ 'name_parser' => $name_parser,'type_parser' => $type_parser,'expr_parser' => $expr_parser,'decl_parser' => $decl_parser ]);$this->main=$stmt_parser;}  public function dumpAst(){var_dump($this->ast);} public function format(){echo $this->beautify();} public function beautify(){return $this->ast->format($this);} public function parse(){$this->ast=$this->main->_program();} public function evalParselet($grammar,$parselet){$token=$this->consumeAndFetch();return(new $parselet)->parse($grammar,$token);}}define('BEGIN_RED',"\033[01;31m");define('END_RED',"\033[0m");define('BEGIN_GREEN',"\033[01;32m");define('END_GREEN',"\033[0m");define('BEGIN_BG_RED',"\033[01;41m");define('END_BG_RED',"\033[0m");define('BEGIN_BOLD',"\033[1m");define('END_BOLD',"\033[0m");define('BEGIN_BLUE',"\033[0;34m");define('END_BLUE',"\033[0m");class SyntaxError extends Exception{private $expected;private $found;private $parser;public function __construct($parameters){$this->expected=$parameters['expected'];$this->found=$parameters['found'];$this->reader=$parameters['parser'];$this->hint=array_key_exists('hint',$parameters) ?$parameters['hint'] :null;} private function extractPieceOfSource(){$out_buffer=[];$position=$this->getPosition();$token_size=$this->getFoundTokenSize();$new_column=$position['column'] - $token_size;$error_line=str_split( explode(PHP_EOL,$this->getOriginalSource()->input)[ $position['line'] - 1 ] );$line_indicator="{$position['line']}| ";$correct_piece=$new_column - 1 <=0 ?[] :array_slice($error_line,0,$new_column);$error_piece=array_slice($error_line,$new_column,$new_column + 10);$out_buffer[]=$line_indicator;$out_buffer[]=BEGIN_GREEN .implode($correct_piece) .END_GREEN;$out_buffer[]=BEGIN_BG_RED .implode($error_piece) .END_BG_RED;$out_buffer[]=PHP_EOL .str_repeat(' ',strlen($line_indicator) + sizeof($correct_piece));$out_buffer[]=BEGIN_BOLD .str_repeat('^',sizeof($error_piece)) .END_BOLD;return implode($out_buffer);} public function getFormattedHint(){if(null ===$this->hint){return '';} return PHP_EOL .PHP_EOL .BEGIN_BLUE .BEGIN_BOLD ."~Hint:" ." {$this->hint}" .END_BLUE .END_BOLD .PHP_EOL;} public function __toString(){$source=$this->extractPieceOfSource();$expected=$this->getExpectedTokenName();$found=$this->getFoundTokenName();$position=$this->getPosition();$hint=$this->getFormattedHint();return $source .PHP_EOL .join([ BEGIN_RED,"*** Hey, I found a syntax error!",PHP_EOL,"    Expecting [",BEGIN_GREEN,$expected,END_GREEN,BEGIN_RED,"]",PHP_EOL,"    Found     [",BEGIN_GREEN,$found,END_GREEN,BEGIN_RED,"]",PHP_EOL,"    Line      {$position['line']}",PHP_EOL,"    Column    ",($position['column'] - $this->getFoundTokenSize() + 1),PHP_EOL,END_RED,$hint ]);} private function getExpectedTokenName(){return is_integer($this->expected) ?Tag::getName($this->expected) :$this->expected;} protected function getFoundTokenName(){$found_tag=$this->found->getTag();return Tag::getName($found_tag) ?:$found_tag;} private function getFoundTokenSize(){if($this->found instanceof Word){return strlen($this->found->lexeme);}  $offset=0;$found_tag=$this->found->getTag();if(Tag::T_STRING ===$found_tag){$offset +=2;} $token_val=$this->found->getContent();return $offset +(0 ===$found_tag ?-1 :strlen(null !==$token_val ?$token_val :$found_tag));} private function getOriginalSource(){return $this->reader->input;} private function getPosition(){return $this->reader->position();}}class DeclParser{use Attachable;public $reader;public function __construct($reader){$this->reader=$reader;} public function _fnSignature(){$name=null;$parameters=[];$type=null;$name=$this->name_parser->_identifier();$this->reader->match('(');if(!$this->reader->consumeIf(')')){do{$parameters[]=$this->stmt_parser->_parameter();} while($this->reader->consumeIf(','));$this->reader->match(')');} if($this->reader->consumeIf('->')){$type=$this->type_parser->_type();} return new FnSignatureStmt($name,$parameters,$type);} public function _fnStmt($is_method=false){$is_short=false;$body=null;if(!$is_method){$this->reader->match(Tag::T_FN);} $signature=$this->_fnSignature();if($is_short=$this->reader->is(':-')){$this->reader->consume();$body=$this->expr_parser->_expr();} else{$body=iterator_to_array($this->stmt_parser->_innerStmtList());$this->reader->match(Tag::T_END);} return new FnStmt($signature,$body,$is_method,$is_short);}}class StmtParser{use Attachable;public $reader;public $checker;public function __construct($reader){$this->reader=$reader;$this->checker=new TokenChecker($reader);} public function _program(){return new ProgramStmt(iterator_to_array($this->_topStmtList()));} public function _topStmtList(){while(!$this->checker->isEoF()){yield $this->_topStmt();}} public function _innerStmtList(){while($this->checker->startsInnerStmt()){yield $this->_innerStmt();}} public function _stmt(){$branch_table=[ Tag::T_IF => '_ifStmt',Tag::T_LET => '_letStmt',Tag::T_WHILE => '_whileStmt',Tag::T_DO => '_exprStmt',Tag::T_FOR => '_forStmt',Tag::T_FOREACH => '_foreachStmt',Tag::T_SWITCH => '_switchStmt',Tag::T_TRY => '_tryStmt',Tag::T_BREAK => '_breakStmt',Tag::T_CONTINUE => '_continueStmt',Tag::T_RAISE => '_raiseStmt',Tag::T_BEGIN => '_blockStmt','^' => '_returnStmt','[' => '_labelStmt' ];foreach($branch_table as $token => $action){if($this->reader->is($token)){$first_class_stmt=$this->{$action}();if($this->reader->is(Tag::T_WHEN) || $this->reader->is(Tag::T_UNLESS)){$tag=$this->reader->consumeAndFetch()->getTag();$predicate=$this->expr_parser->_expr();return new PostConditionalStmt($first_class_stmt,$predicate,$tag);} return $first_class_stmt;}} $params=[ 'expected' => 'statement','found' => $this->reader->lookahead,'parser' => $this->reader ];if(0 ===$this->reader->lookahead->getTag()){throw new EOFError($params);};throw new SyntaxError($params);} public function _exprStmt(){$this->reader->match(Tag::T_DO);$expr=$this->expr_parser->_expr();return new ExprStmt($expr);} public function _blockStmt(){$this->reader->match(Tag::T_BEGIN);$body=iterator_to_array($this->_innerStmtList());$this->reader->match(Tag::T_END);return new BlockStmt($body);} public function _ifStmt(){$this->reader->match(Tag::T_IF);$condition=$this->expr_parser->_expr();$body=new StmtList(iterator_to_array($this->_innerStmtList()));$elif=iterator_to_array($this->_elifList());$else=$this->_optElse();$this->reader->match(Tag::T_END);return new IfStmt($condition,$body,$elif,$else);} public function _letStmt(){$this->reader->match(Tag::T_LET);$mutable=$this->reader->consumeIf(Tag::T_MUT);$name=$this->name_parser->_identifier();$type=$this->reader->consumeIf('::') ?$this->type_parser->_type() :null;$value=$this->reader->consumeIf(':-') ?$this->expr_parser->_expr() :null;return new LetStmt($name,$type,$value,$mutable);} public function _whileStmt(){$this->reader->match(Tag::T_WHILE);$condition=$this->expr_parser->_expr();$body=iterator_to_array($this->_innerStmtList());$this->reader->match(Tag::T_END);return new WhileStmt($condition,$body);} public function _forStmt(){$this->reader->match(Tag::T_FOR);$variable=$this->name_parser->_identifier();$this->reader->match(Tag::T_FROM);$from=$this->expr_parser->_expr();$this->reader->match(Tag::T_TO);$to=$this->expr_parser->_expr();$by=null;if($this->reader->consumeIf(Tag::T_BY)){$by=$this->expr_parser->_expr();} $body=new StmtList(iterator_to_array($this->_innerStmtList()));$this->reader->match(Tag::T_END);return new ForStmt($variable,$from,$to,$by,$body);} public function _foreachStmt(){$key=null;$this->reader->match(Tag::T_FOREACH);if($this->reader->is(Tag::T_IDENT)){$alias=$this->name_parser->_identifier();if($this->reader->consumeIf(':')){$key=$alias;$alias=$this->name_parser->_identifier();}} else{$alias=$this->name_parser->_identifier();} $this->reader->match(Tag::T_IN);$iterable=$this->expr_parser->_expr();$body=iterator_to_array($this->_innerStmtList());$this->reader->match(Tag::T_END);return new ForeachStmt($key,$alias,$iterable,$body);} public function _switchStmt(){$this->reader->match(Tag::T_SWITCH);$value=$this->expr_parser->_expr();$cases=iterator_to_array($this->_caseStmtList());$this->reader->match(Tag::T_END);return new SwitchStmt($value,$cases);} public function _tryStmt(){$this->reader->match(Tag::T_TRY);$body=new StmtList(iterator_to_array($this->_innerStmtList()));$rescues=iterator_to_array($this->_rescueStmtList());$finally=$this->_optFinally();$this->reader->match(Tag::T_END);return new TryStmt($body,$rescues,$finally);} public function _breakStmt(){$this->reader->match(Tag::T_BREAK);$label=$this->_optLabel();return new BreakStmt($label);} public function _continueStmt(){$this->reader->match(Tag::T_CONTINUE);$label=$this->_optLabel();return new ContinueStmt($label);} public function _raiseStmt(){$this->reader->match(Tag::T_RAISE);$expression=$this->expr_parser->_expr();return new RaiseStmt($expression);} public function _returnStmt(){$this->reader->match('^');$expression=$this->expr_parser->_optExpr();return new ReturnStmt($expression);} public function _labelStmt(){$this->reader->match('[');$label_name=$this->name_parser->_identifier();$this->reader->match(']');$stmt=$this->_innerStmt();return new LabelStmt($label_name,$stmt);} public function _elifList(){while($this->reader->consumeIf(Tag::T_ELIF)){$condition=$this->expr_parser->_expr();$body=iterator_to_array($this->_innerStmtList());yield new ElifStmt($condition,$body);}} public function _optElse(){if(!$this->reader->is(Tag::T_ELSE)){return null;} $this->reader->consume();return new StmtList(iterator_to_array($this->_innerStmtList()));} public function _topStmt(){$decl_table=[ Tag::T_FN => '_fnStmt' ];$next_tag=$this->reader->lookahead->getTag();if(array_key_exists($next_tag,$decl_table)){return call_user_func([$this->decl_parser,$decl_table[$next_tag]]);} return $this->_stmt();} public function _innerStmt(){$branch_table=[ Tag::T_FN => '_fnStmt' ];$next_tag=$this->reader->lookahead->getTag();return array_key_exists($next_tag,$branch_table) ?call_user_func([$this,$branch_table[$next_tag]]) :$this->_stmt();} public function _parameter(){$name=$this->name_parser->_identifier();$type=null;if($this->reader->consumeIf('::')){$type=$this->type_parser->_type();} return (object) [ 'name' => $name,'type' => $type ];} public function _caseStmtList(){$cases=[Tag::T_CASE,Tag::T_ELSE];while(in_array($this->reader->lookahead->getTag(),$cases,true)){$is_else=$this->reader->is(Tag::T_ELSE);$this->reader->consume();$value=$is_else ?null :$this->expr_parser->_expr();$body=new StmtList(iterator_to_array($this->_innerStmtList()));yield new CaseStmt($value,$body,$is_else);}} public function _rescueStmtList(){while($this->reader->consumeIf(Tag::T_RESCUE)){$this->reader->match('(');$exception_class=$this->name_parser->_qualifiedName();$variable=$this->name_parser->_identifier();$this->reader->match(')');$body=new StmtList(iterator_to_array($this->_innerStmtList()));yield [ "exception_class" => $exception_class,"variable" => $variable,"body" => $body ];}} public function _optFinally(){if($this->reader->consumeIf(Tag::T_FINALLY)){$body=new StmtList(iterator_to_array($this->_innerStmtList()));return $body;} return null;} public function _optLabel(){return $this->reader->is(Tag::T_IDENT) ?$this->name_parser->_identifier() :null;}}trait Attachable{public function attachParsers($parsers){foreach($parsers as $name => $parser){$this->{$name}=$parser;}}}} namespace QuackCompiler\Ast{ use \QuackCompiler\Ast\Stmt\ConstStmt;use \QuackCompiler\Intl\Localization;use \QuackCompiler\Parser\Parser;use \QuackCompiler\Scope\Kind;use \QuackCompiler\Scope\Scope;use \QuackCompiler\Scope\ScopeError;use \ReflectionClass;abstract class Node{abstract public function format(Parser $parser);abstract public function injectScope(&$parent_scope);}} namespace QuackCompiler\Ast\Expr{ use \QuackCompiler\Ast\Node;use \QuackCompiler\Ast\Types\ObjectType;use \QuackCompiler\Intl\Localization;use \QuackCompiler\Parser\Parser;use \QuackCompiler\Scope\ScopeError;use \QuackCompiler\Types\NativeQuackType;use \QuackCompiler\Ast\Types\LiteralType;use \QuackCompiler\Lexer\Tag;use \QuackCompiler\Scope\Kind;use \QuackCompiler\Scope\Meta;use \QuackCompiler\Scope\Scope;use \QuackCompiler\Ast\Types\AtomType;use \QuackCompiler\Types\TypeError;use \QuackCompiler\Ast\Types\FunctionType;use \QuackCompiler\Ast\Types\GenericType;use \QuackCompiler\Parselets\Expr\LambdaParselet;use \QuackCompiler\Ast\Types\ListType;use \QuackCompiler\Lexer\Token;use \QuackCompiler\Ast\Types\MapType;abstract class Expr extends Node{protected $parentheses_level=0;public function addParentheses(){$this->parentheses_level++;} public function removeParentheses(){$this->parentheses_level--;} protected function parenthesize($source){$level=$this->parentheses_level;return str_repeat('(',$level) .$source .str_repeat(')',$level);}}class ObjectExpr extends Expr{public $keys;public $values;public function __construct($keys,$values){$this->keys=$keys;$this->values=$values;} public function format(Parser $parser){$source='%{';$keys=&$this->keys;$values=&$this->values;if(sizeof($this->keys) > 0){$source .=PHP_EOL;$parser->openScope();$source .=implode(',' .PHP_EOL,array_map(function($index) use($keys,$values,$parser){$subsource=$parser->indent();$subsource .=$keys[$index];$subsource .=': ';$subsource .=$values[$index]->format($parser);return $subsource;},range(0,sizeof($keys) - 1)));$parser->closeScope();$source .=PHP_EOL;$source .=$parser->indent();} $source .='}';return $this->parenthesize($source);} public function injectScope(&$parent_scope){$defined=[];$index=0;while($index < sizeof($this->keys)){$key=$this->keys[$index];$value=$this->values[$index];if(array_key_exists($key,$defined)){throw new ScopeError(Localization::message('SCO050',[$key]));} $value->injectScope($parent_scope);$defined[$key]=true;$index++;}} public function getType(){$properties=[];for($i=0,$size=sizeof($this->keys);$i < $size;$i++){$properties[$this->keys[$i]]=$this->values[$i]->getType();} return new ObjectType($properties);}}class NilExpr extends Expr{public function format(Parser $_){return $this->parenthesize('nil');} public function injectScope(&$parent_scope){} public function getType(){return new LiteralType(NativeQuackType::T_NIL);}}class PartialFuncExpr extends Expr{public $operator;public $right;public function __construct($operator,$right=null){$this->operator=$operator;$this->right=$right;} public function format(Parser $parser){$source='&(';$source .=Tag::getOperatorLexeme($this->operator);if(null !==$this->right){$source .=' ';$source .=$this->right->format($parser);} $source .=')';return $this->parenthesize($source);} public function injectScope(&$parent_scope){$this->right->injectScope($parent_scope);}}class WhereExpr extends Expr{public $expr;public $clauses;public function __construct(Expr $expr,$clauses){$this->expr=$expr;$this->clauses=$clauses;} public function format(Parser $parser){$first=true;$size=sizeof($this->clauses);$processed=0;$source=$this->expr->format($parser);$source .=PHP_EOL;$parser->openScope();$source .=$parser->indent();$source .='where ';foreach($this->clauses as $clause){$key=&$clause[0];$value=&$clause[1];$processed++;if(!$first){$source .=$parser->indent();$source .='    , ';} else{$first=false;} $source .=$key;$source .=' :- ';$source .=$value->format($parser);if($processed < $size){$source .=PHP_EOL;}} $parser->closeScope();return $this->parenthesize($source);} public function injectScope(&$parent_scope){$this->scope=new Scope($parent_scope);foreach($this->clauses as $clause){$key=&$clause[0];$value=&$clause[1];if($this->scope->hasLocal($key)){throw new ScopeError(Localization::message('SCO120',[$key]));} $value->injectScope($this->scope);$this->scope->insert($key,Kind::K_VARIABLE | Kind::K_INITIALIZED);} $this->expr->injectScope($this->scope);} public function getType(){foreach($this->clauses as $clause){$this->scope->setMeta(Meta::M_TYPE,$clause[0],$clause[1]->getType());}  return $this->expr->getType();}}class BoolExpr extends Expr{public $value;public function __construct($value){$this->value=$value;} public function format(Parser $_){$source=var_export($this->value,true);return $this->parenthesize($source);} public function injectScope(&$parent_scope){} public function getType(){return new LiteralType(NativeQuackType::T_BOOL);}}class PostfixExpr extends Expr{public $left;public $operator;public function __construct($left,$operator){$this->left=$left;$this->operator=$operator;} public function format(Parser $parser){$source=$this->left->format($parser);$source .=Tag::getOperatorLexeme($this->operator);return $this->parenthesize($source);} public function injectScope(&$parent_scope){$this->left->injectScope($parent_scope);} public function getType(){return new LiteralType(NativeQuackType::T_NIL);}}class AtomExpr extends Expr{public $value;public function __construct($value){$this->value=$value;} public function format(Parser $parser){$source=$this->value;return $this->parenthesize($source);} public function injectScope(&$parent_scope){} public function getType(){return new AtomType($this->value);}}class RegexExpr extends Expr{public $value;public function __construct($value){$this->value=$value;} public function format(Parser $parser){$source=$this->value;return $source;} public function injectScope(&$parent_scope){} public function getType(){return new LiteralType(NativeQuackType::T_REGEX);}}class WhenExpr extends Expr{public $cases;public function __construct($cases){$this->cases=$cases;} public function format(Parser $parser){$source='when';$source .=PHP_EOL;$parser->openScope();for($i=0,$l=sizeof($this->cases);$i < $l;$i++){$obj=$this->cases[$i];$source .=$parser->indent();if(null !==$obj->condition){$source .=$obj->condition->format($parser);$source .=' -> ';} else{$source .='else ';} $source .=$obj->action->format($parser);if($i + 1 !==$l){$source .=',';$source .=PHP_EOL;}} $parser->closeScope();$source .=PHP_EOL;$source .=$parser->indent();$source .='end';return $this->parenthesize($source);} public function injectScope(&$parent_scope){foreach($this->cases as $case){if(null !==$case->condition){$case->condition->injectScope($parent_scope);} $case->action->injectScope($parent_scope);}} public function getType(){$conds=0;$type=null;foreach($this->cases as $case){$conds++;if(null !==$case->condition){$condition_type=$case->condition->getType();if(!$condition_type->isBoolean()){throw new TypeError(Localization::message('TYP200',[$conds,$condition_type]));}} $action_type=$case->action->getType();if(null ===$type){$type=$action_type;} else if(!$type->check($action_type)){throw new TypeError(Localization::message('TYP210',[$type,$conds,$action_type]));}} return $type;}}class NameExpr extends Expr{public $name;public function __construct($name){$this->name=$name;} public function format(Parser $parser){$source=$this->name;return $this->parenthesize($source);} public function injectScope(&$parent_scope){$this->scope=$parent_scope;$symbol=$parent_scope->lookup($this->name);if(null ===$symbol){throw new ScopeError(Localization::message('SCO020',[$this->name]));}      $refcount=$parent_scope->getMeta(Meta::M_REF_COUNT,$this->name);if(null ===$refcount){$parent_scope->setMeta(Meta::M_REF_COUNT,$this->name,1);} else{$parent_scope->setMeta(Meta::M_REF_COUNT,$this->name,$refcount + 1);}} public function getType(){$symbol=$this->scope->lookup($this->name);if($symbol & Kind::K_VARIABLE){$variable_scope=$this->scope->getSymbolScope($this->name);return $variable_scope->getMeta(Meta::M_TYPE,$this->name);} throw new TypeError(Localization::message('TYP190',[$this->name]));}}class CallExpr extends Expr{public $callee;public $arguments;public function __construct($callee,$arguments){$this->callee=$callee;$this->arguments=$arguments;} public function format(Parser $parser){$source=$this->callee->format($parser);$source .='(';$source .=implode(', ',array_map(function(Expr $arg) use($parser){return $arg->format($parser);},$this->arguments));$source .=')';return $this->parenthesize($source);} public function injectScope(&$parent_scope){$this->callee->injectScope($parent_scope);foreach($this->arguments as $arg){$arg->injectScope($parent_scope);}} public function getType(){$callee_type=$this->callee->getType();if(!($callee_type instanceof FunctionType)){throw new TypeError(Localization::message('TYP310',[$callee_type]));}  $expected_arguments=sizeof($callee_type->parameters);$received_arguments=sizeof($this->arguments);if($received_arguments !==$expected_arguments){throw new TypeError(Localization::message('TYP320',[$callee_type,$expected_arguments,$received_arguments]));}  for($i=0;$i < $expected_arguments;$i++){$expected_type=$callee_type->parameters[$i];$received_type=$this->arguments[$i]->getType();if(!$expected_type->check($received_type)){throw new TypeError(Localization::message('TYP330',[$i + 1,$expected_type,$received_type]));}} return $callee_type->return;}}class OperatorExpr extends Expr{public $left;public $operator;public $right;public function __construct(Expr $left,$operator,$right){$this->left=$left;$this->operator=$operator;$this->right=$right;} private function isMemberAccess(){return '.' ===$this->operator;} public function format(Parser $parser){$blanks=$this->isMemberAccess() ?'' :' ';$source=$this->left->format($parser);$source .=$blanks;$source .=Tag::getOperatorLexeme($this->operator);$source .=$blanks;$source .=$this->isMemberAccess() ?$this->right :$this->right->format($parser);return $this->parenthesize($source);} public function injectScope(&$parent_scope){$this->scope=&$parent_scope;$this->left->injectScope($parent_scope);if(!$this->isMemberAccess()){$this->right->injectScope($parent_scope);} if(':-' ===$this->operator){if($this->left instanceof NameExpr){$symbol=$parent_scope->lookup($this->left->name);if(~$symbol & Kind::K_VARIABLE){throw new ScopeError(Localization::message('SCO070',[$this->left->name]));}  if(~$symbol & Kind::K_MUTABLE){throw new ScopeError(Localization::message('SCO080',[$this->left->name]));}} else{$valid_assignment=$this->left instanceof AccessExpr || $this->left instanceof ArrayExpr;if(!$valid_assignment){throw new ScopeError(Localization::message('SCO090',[]));}   if($this->left instanceof ArrayExpr){foreach($this->left->items as $item){if(!($item instanceof NameExpr)){throw new ScopeError(Localization::message('SCO100',[]));}}}}}} public function getType(){$type=(object) [ 'left' => $this->left->getType(),'right' => 'string' ===gettype($this->right) ?$this->right :$this->right->getType() ];$op_name=Tag::getOperatorLexeme($this->operator);if('.' ===$this->operator){if($type->left instanceof ObjectType && isset($type->left->properties[$this->right])){return $type->left->properties[$this->right];} throw new TypeError(Localization::message('TYP090',[$type->left,$type->right]));}   if(':-' ===$this->operator){if(!$type->left->check($type->right)){$target=$this->left instanceof NameExpr ?"`{$this->left->name}' :: {$type->left}" :$type->right;throw new TypeError(Localization::message('TYP100',[$type->right,$target]));} return $type->left;}  $numeric_op=['+','-','*','**','/','>>','<<',Tag::T_MOD];if(in_array($this->operator,$numeric_op,true)){if('+' ===$this->operator && $type->left->isString() && $type->right->isString()){return new LiteralType(NativeQuackType::T_STR);} if($type->left->isNumber() && $type->right->isNumber()){return new LiteralType(NativeQuackType::T_NUMBER);} throw new TypeError(Localization::message('TYP110',[$op_name,$type->left,$op_name,$type->right]));}  $eq_op=['=','<>','>','>=','<','<='];if(in_array($this->operator,$eq_op,true)){if(!$type->left->check($type->right)){throw new TypeError(Localization::message('TYP130',[$type->left,$op_name,$type->right]));} return new LiteralType(NativeQuackType::T_BOOL);}  if('=~' ===$this->operator){if(!$type->left->isString() || !$type->right->isRegex()){throw new TypeError(Localization::message('TYP110',[$op_name,$type->left,$op_name,$type->right]));} return new LiteralType(NativeQuackType::T_BOOL);}  $bool_op=[Tag::T_AND,Tag::T_OR,Tag::T_XOR];if(in_array($this->operator,$bool_op,true)){if($type->left->isBoolean() && $type->right->isBoolean()){return new LiteralType(NativeQuackType::T_BOOL);} if($type->left->isNumber() && $type->right->isNumber()){return new LiteralType(NativeQuackType::T_NUMBER);} throw new TypeError(Localization::message('TYP110',[$op_name,$type->left,$op_name,$type->right]));}}}class LambdaExpr extends Expr{public $parameters;public $kind;public $body;public $has_brackets;private $argument_types;public function __construct($parameters,$kind,$body,$has_brackets){$this->parameters=$parameters;$this->kind=$kind;$this->body=$body;$this->has_brackets=$has_brackets;$this->argument_types=[];} public function format(Parser $parser){$source='&';switch(sizeof($this->parameters)){case 0:$source .='[]';break;case 1:if($this->has_brackets){$source .='[' .$this->parameters[0]->name;if(isset($this->parameters[0]->type)){$source .=' :: ' .$this->parameters[0]->type;} $source .=']';} else{$source .=$this->parameters[0]->name;} break;default:$source .='[';$source .=implode(', ',array_map(function($param){$parameter=$param->name;if(null !==$param->type){$parameter .=" :: {$param->type}";} return $parameter;},$this->parameters));$source .=']';} $source .=' -> ';if(LambdaParselet::TYPE_EXPRESSION ===$this->kind){$source .=$this->body->format($parser);} else{$source .='begin' .PHP_EOL;$parser->openScope();foreach($this->body as $stmt){$source .=$parser->indent();$source .=$stmt->format($parser);} $parser->closeScope();$source .=$parser->indent();$source .='end';$source .=PHP_EOL;} return $this->parenthesize($source);} public function injectScope(&$parent_scope){$this->scope=new Scope($parent_scope);foreach($this->parameters as $param){if($this->scope->hasLocal($param->name)){throw new ScopeError(Localization::message('SCO010',[$param->name]));} $this->scope->insert($param->name,Kind::K_INITIALIZED | Kind::K_VARIABLE | Kind::K_PARAMETER | Kind::K_MUTABLE);$param_type=isset($param->type) ?$param->type :new GenericType(Meta::nextGenericVarName());$this->argument_types[$param->name]=$param_type;$this->scope->setMeta(Meta::M_TYPE,$param->name,$param_type);} if(LambdaParselet::TYPE_STATEMENT ===$this->kind){foreach($this->body as $node){$node->injectScope($this->scope);}} else{$this->body->injectScope($this->scope);}} public function getType(){if(LambdaParselet::TYPE_EXPRESSION ===$this->kind){return new FunctionType(array_map(function($parameter){return $this->argument_types[$parameter->name];},$this->parameters),$this->body->getType());}  return null;}}class BlockExpr extends Expr{public $body;public function __construct($body){$this->body=$body;} public function format(Parser $parser){$source='&{';if(sizeof($this->body->stmt_list) > 0){$source .=PHP_EOL;$parser->openScope();$source .=$this->body->format($parser);$parser->closeScope();$source .=$parser->indent();} $source .='}';return $this->parenthesize($source);} public function injectScope(&$parent_scope){$this->scope=new Scope($parent_scope);foreach($this->body->stmt_list as $node){$node->injectScope($this->scope);}} public function getType(){return new LiteralType(NativeQuackType::T_BLOCK);}}class ArrayExpr extends Expr{public $items;public function __construct($items){$this->items=$items;} public function format(Parser $parser){$source='{';if(sizeof($this->items) > 0){$source .=' ';$source .=implode(', ',array_map(function($item) use($parser){return $item->format($parser);},$this->items));$source .=' ';} $source .='}';return $this->parenthesize($source);} public function injectScope(&$parent_scope){foreach($this->items as $item){$item->injectScope($parent_scope);}} public function getType(){if(0 ===sizeof($this->items)){return new ListType(new GenericType(Meta::nextGenericVarName()));}  $subtype=$this->items[0]->getType();foreach(array_slice($this->items,1) as $item){$type=$item->getType();if(!$subtype->check($type)){throw new TypeError(Localization::message('TYP020',[$type,$subtype]));}} return new ListType($subtype);}}class RangeExpr extends Expr{public $from;public $to;public $by;public function __construct($from,$to,$by){$this->from=$from;$this->to=$to;$this->by=$by;} public function format(Parser $parser){$source=$this->from->format($parser);$source .=' .. ';$source .=$this->to->format($parser);if(null !==$this->by){$source .=' by ';$source .=$this->by->format($parser);} return $this->parenthesize($source);} public function injectScope(&$parent_scope){$this->from->injectScope($parent_scope);$this->to->injectScope($parent_scope);if(null !==$this->by){$this->by->injectScope($parent_scope);}} public function getType(){$type=(object) [ 'from' => $this->from->getType(),'to' => $this->to->getType(),'by' => null !==$this->by ?$this->by->getType() :null ];$throw_error_on=function($operand,$got){throw new TypeError(Localization::message('TYP220',[$operand,$got]));};if(!$type->from->isNumber()){$throw_error_on('from',$type->from);} if(!$type->to->isNumber()){$throw_error_on('to',$type->to);} if(null !==$type->by && !$type->by->isNumber()){$throw_error_on('by',$type->by);} return new ListType(new LiteralType(NativeQuackType::T_NUMBER));}}class PrefixExpr extends Expr{private $operator;private $right;public function __construct(Token $operator,Expr $right){$this->operator=$operator->getTag();$this->right=$right;} public function format(Parser $parser){$source=Tag::T_NOT ===$this->operator ?'not ' :$this->operator;$source .=$this->right->format($parser);return $this->parenthesize($source);} public function injectScope(&$parent_scope){$this->right->injectScope($parent_scope);} public function getType(){$right_type=$this->right->getType();$op_name=Tag::getOperatorLexeme($this->operator);$type_error=new TypeError(Localization::message('TYP230',[$op_name,$right_type]));switch($this->operator){case '+':case '-':case '~':if($right_type->isNumber()){return $right_type;} throw $type_error;case Tag::T_NOT:if($right_type->isBoolean()){return $right_type;} throw $type_error;}}}class MapExpr extends Expr{public $keys;public $values;public function __construct($keys,$values){$this->keys=$keys;$this->values=$values;} public function format(Parser $parser){$source='#{';$keys=&$this->keys;$values=&$this->values;if(sizeof($this->keys) > 0){$source .=' ';$source .=implode(', ',array_map(function($index) use(&$keys,&$values,$parser){$subsource=$keys[$index]->format($parser);$subsource .=': ';$subsource .=$values[$index]->format($parser);return $subsource;},range(0,sizeof($keys) - 1)));$source .=' ';} $source .='}';return $this->parenthesize($source);} public function injectScope(&$parent_scope){foreach($this->keys as $key){$key->injectScope($parent_scope);} foreach($this->values as $value){$value->injectScope($parent_scope);}} public function getType(){$size=sizeof($this->keys);if(0 ===$size){return new MapType( new GenericType(Meta::nextGenericVarName()),new GenericType(Meta::nextGenericVarName()));} $original_key_type=$this->keys[0]->getType();$original_value_type=$this->values[0]->getType();for($i=1;$i < $size;$i++){$key_type=$this->keys[$i]->getType();$value_type=$this->values[$i]->getType();if(!$original_key_type->check($key_type)){throw new TypeError(Localization::message('TYP070',[$i,$original_key_type,$key_type]));} if(!$original_value_type->check($value_type)){throw new TypeError(Localization::message('TYP080',[$i,$original_value_type,$value_type]));}} return new MapType($original_key_type,$original_value_type);}}class NumberExpr extends Expr{public $value;public $type;public $notation;public function __construct($value,$type,$notation='decimal'){$this->value=$value;$this->type=$type;$this->notation=$notation;} public function format(Parser $parser){$source=$this->value;return $this->parenthesize($source);} public function injectScope(&$parent_scope){} public function getType(){return new LiteralType(NativeQuackType::T_NUMBER);}}class AccessExpr extends Expr{public $left;public $index;public function __construct($left,$index){$this->left=$left;$this->index=$index;} public function format(Parser $parser){$source=$this->left->format($parser);$source .=' {';$source .=$this->index->format($parser);$source .='}';return $this->parenthesize($source);} public function injectScope(&$parent_scope){$this->left->injectScope($parent_scope);$this->index->injectScope($parent_scope);} public function getType(){$left_type=$this->left->getType();$index_type=$this->index->getType();if($left_type instanceof ListType){if(!$index_type->isNumber()){throw new TypeError(Localization::message('TYP040',[$index_type]));}  return $left_type->type;}  if($left_type instanceof MapType){if(!$index_type->check($left_type->key)){throw new TypeError(Localization::message('TYP050',[$left_type->key,$index_type]));}  return $left_type->value;}  if($left_type->isString()){if(!$index_type->isNumber()){throw new TypeError(Localization::message('TYP040',[$index_type]));}  return $left_type;} throw new TypeError(Localization::message('TYP060',[$left_type]));}}class TernaryExpr extends Expr{public $condition;public $then;public $else;public function __construct($condition,$then,$else){$this->condition=$condition;$this->then=$then;$this->else=$else;} public function format(Parser $parser){$source=$this->condition->format($parser);$source .=' then ';$source .=$this->then->format($parser);$source .=' else ';$source .=$this->else->format($parser);return $source;} public function injectScope(&$parent_scope){$this->condition->injectScope($parent_scope);$this->then->injectScope($parent_scope);$this->else->injectScope($parent_scope);} public function getType(){$condition=$this->condition->getType();if(!$condition->isBoolean()){throw new TypeError(Localization::message('TYP240',[$condition_type]));} $truthy=$this->then->getType();$falsy=$this->else->getType();if(!$truthy->check($falsy)){throw new TypeError(Localization::message('TYP250',[$truthy,$falsy]));} return $truthy;}}class StringExpr extends Expr{public $value;public $delimiter;public function __construct($value,$delimiter){$this->value=$value;$this->delimiter=$delimiter;} public function format(Parser $parser){$source=$this->delimiter;$source .=$this->value;$source .=$this->delimiter;return $this->parenthesize($source);} public function injectScope(&$parent_scope){} public function getType(){return new LiteralType(NativeQuackType::T_STR);}}} namespace QuackCompiler\Ast\Expr\JSX{ use \QuackCompiler\Ast\Expr\Expr;use \QuackCompiler\Ast\Expr\StringExpr;use \QuackCompiler\Ast\Types\AtomType;use \QuackCompiler\Ast\Types\LiteralType;use \QuackCompiler\Ast\Types\ObjectType;use \QuackCompiler\Intl\Localization;use \QuackCompiler\Parser\Parser;use \QuackCompiler\Types\NativeQuackType;use \QuackCompiler\Types\TypeError;class JSXElement extends Expr{public $name;public $attributes;public $children;public function __construct($name,$attributes,$children=null){$this->name=$name;$this->attributes=$attributes;$this->children=$children;} public function format(Parser $parser){$attributes=empty($this->attributes) ?'' :' ';$attributes .=implode(' ',array_map(function($attr) use($parser){$source=$attr[0];if(isset($attr[1])){$source .=': ';if($attr[1] instanceof StringExpr){$source .=$attr[1]->format($parser);} else{$source .="{ {$attr[1]->format($parser)} }";}} return $source;},$this->attributes));if(null ===$this->children){return $this->parenthesize("<{$this->name}{$attributes} />");} $parenthesized=$this->parentheses_level > 0;$source='';if($parenthesized){$parser->openScope();$source .=PHP_EOL .$parser->indent();} $source .="<{$this->name}{$attributes}>" .PHP_EOL;$parser->openScope();foreach($this->children as $child){$source .=$parser->indent();if($child instanceof JSXElement){$source .=$child->format($parser);} else{$source .="{ {$child->format($parser)} }";} $source .=PHP_EOL;} $parser->closeScope();$source .=$parser->indent() ."</{$this->name}>";if($parenthesized){$source .=PHP_EOL;$parser->closeScope();} return $this->parenthesize($source);} public function injectScope(&$parent_scope){foreach($this->attributes as $attr){if(isset($attr[1])){$attr[1]->injectScope($parent_scope);}} if(null ===$this->children){return;} foreach($this->children as $child){$child->injectScope($parent_scope);}} public function getType(){foreach($this->attributes as $attr){$name=$attr[0];$type=isset($attr[1]) ?$attr[1]->getType() :new LiteralType(NativeQuackType::T_BOOL);} if(null ===$this->children){return new AtomType(':jsx_element');} foreach($this->children as $child){$type=$child->getType();if(!$type->isString() && !$type->isAtom(':jsx_element')){throw new TypeError(Localization::message('TYP410',[$type]));}} return new AtomType(':jsx_element');}}} namespace QuackCompiler\Ast\Stmt{ use \QuackCompiler\Ast\Node;use \QuackCompiler\Parser\Parser;use \QuackCompiler\Intl\Localization;use \QuackCompiler\Scope\Kind;use \QuackCompiler\Scope\Meta;use \QuackCompiler\Scope\ScopeError;use \QuackCompiler\Scope\Scope;use \QuackCompiler\Ast\Types\FunctionType;use \QuackCompiler\Types\TypeError;use \QuackCompiler\Ast\Stmt\BlockStmt;use \QuackCompiler\Types\NativeQuackType;use \QuackCompiler\Ast\Types\ListType;use \QuackCompiler\Ast\Types\LiteralType;use \QuackCompiler\Ast\Types\MapType;use \QuackCompiler\Ast\Expr\Expr;use \QuackCompiler\Lexer\Tag;use \QuackCompiler\Ast\Types\GenericType;use \Exception;use \QuackCompiler\Scope\Symbol;abstract class Stmt extends Node{}class RaiseStmt extends Stmt{public $expression;public function __construct($expression){$this->expression=$expression;} public function format(Parser $parser){$source='raise ';$source .=$this->expression->format($parser);$source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){$this->expression->injectScope($parent_scope);}}class StmtList extends Stmt{public $stmt_list;public function __construct($stmt_list){$this->stmt_list=$stmt_list;} public function format(Parser $parser){$source='';foreach($this->stmt_list as $stmt){$source .=$parser->indent();$source .=$stmt->format($parser);} return $source;} public function injectScope(&$parent_scope){} public function runTypeChecker(){foreach($this->stmt_list as $stmt){$stmt->runTypeChecker();}}}class BreakStmt extends Stmt{public $label;public $is_explicit;public function __construct($label=null){$this->label=$label;$this->is_explicit=null !==$label;} public function format(Parser $parser){$source='break';if($this->is_explicit){$source .=' ';$source .=$this->label;} $source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){if(!$this->is_explicit){$label=$parent_scope->getMetaInContext(Meta::M_LABEL);if(null ===$label){throw new ScopeError(Localization::message('SCO140',['break']));}} else{$meta_label=$parent_scope->getMetaInContext(Meta::M_LABEL);if(null ===$meta_label){throw new ScopeError(Localization::message('SCO140',['break']));} $label=$parent_scope->lookup($this->label);if(null ===$label){throw new ScopeError(Localization::message('SCO150',['break',$this->label]));}  if(~$label & Kind::K_LABEL){throw new ScopeError(Localization::message('SCO160',['break',$this->label]));} $refcount=$parent_scope->getMeta(Meta::M_REF_COUNT,$this->label);if(null ===$refcount){$parent_scope->setMeta(Meta::M_REF_COUNT,$this->label,1);} else{$parent_scope->setMeta(Meta::M_REF_COUNT,$this->label,$refcount + 1);}}} public function runTypeChecker(){}}class TryStmt extends Stmt{public $try;public $rescues;public $finally;public function __construct($try,$rescues,$finally){$this->try=$try;$this->rescues=$rescues;$this->finally=$finally;} public function format(Parser $parser){$source='try';$source .=PHP_EOL;$parser->openScope();$source .=$this->try->format($parser);$parser->closeScope();foreach($this->rescues as $rescue){$obj=(object) $rescue;$source .=$parser->indent();$source .='rescue (';$source .=implode('.',$obj->exception_class);$source .=' ';$source .=$obj->variable;$source .=')';$source .=PHP_EOL;$parser->openScope();$source .=$obj->body->format($parser);$parser->closeScope();} if(null !==$this->finally){$source .=$parser->indent();$source .='finally';$source .=PHP_EOL;$parser->openScope();$source .=$this->finally->format($parser);$parser->closeScope();} $source .=$parser->indent();$source .='end';$source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){$this->try->scope=new Scope($parent_scope);foreach($this->try->stmt_list as $node){$node->injectScope($this->try->scope);}  foreach(array_map(function($item){return (object) $item;},$this->rescues) as $rescue){$rescue->body->scope=new Scope($parent_scope);$rescue->body->scope->insert($rescue->variable,Kind::K_VARIABLE | Kind::K_INITIALIZED);foreach($rescue->body->stmt_list as $node){$node->injectScope($rescue->body->scope);}}  if(null !==$this->finally){$this->finally->scope=new Scope($parent_scope);foreach($this->finally->stmt_list as $node){$node->injectScope($this->finally->scope);}}} public function runTypeChecker(){$this->try->runTypeChecker();foreach(array_map(function($item){return (object) $item;},$this->rescues) as $rescue){$rescue->body->runTypeChecker();} if(null !==$this->finally){$this->finally->runTypeChecker();}}}class FnStmt extends Stmt{public $signature;public $body;public $is_method;public $is_short;public function __construct(FnSignatureStmt $signature,$body,$is_method,$is_short){$this->signature=$signature;$this->body=$body;$this->is_method=$is_method;$this->is_short=$is_short;$this->name=$this->signature->name;} public function format(Parser $parser){$source=$this->is_method ?'' :'fn ';$source .=$this->signature->format($parser);if($this->is_short){$source .=' :- ';$source .=$this->body->format($parser);} else{$source .=PHP_EOL;$parser->openScope();foreach($this->body as $stmt){$source .=$parser->indent();$source .=$stmt->format($parser);} $parser->closeScope();$source .=$parser->indent();$source .='end';} $source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){$parent_scope->insert($this->signature->name,Kind::K_VARIABLE | Kind::K_FUNCTION);$this->scope=new Scope($parent_scope);$this->signature->injectScope($this->scope);if($this->is_short){$this->body->injectScope($this->scope);} else{foreach($this->body as $node){$node->injectScope($this->scope);}}} public function runTypeChecker(){$parameters_types=$this->signature->getParametersTypes();if(null !==$this->signature->type){$function_type=new FunctionType($parameters_types,$this->signature->type);$this->scope->setMeta(Meta::M_TYPE,$this->signature->name,$function_type);$this->injectParametersTypes($parameters_types);$body_type=$this->body->getType();if(!$this->signature->type->check($body_type)){throw new TypeError(Localization::message('TYP380',[$this->signature->type,$body_type]));}} else{$this->injectParametersTypes($parameters_types);$body_type=$this->body->getType();$function_type=new FunctionType($parameters_types,$body_type);$this->scope->setMeta(Meta::M_TYPE,$this->signature->name,$function_type);}} private function injectParametersTypes($parameters_types){$size=sizeof($parameters_types);for($i=0;$i < $size;$i++){$parameter=$this->signature->parameters[$i]->name;$type=$parameters_types[$i];$this->scope->setMeta(Meta::M_TYPE,$parameter,$type);}}}class ReturnStmt extends Stmt{public $expression;public function __construct($expression=null){$this->expression=$expression;} public function format(Parser $parser){$source='^';if(null !==$this->expression){$source .=' ';$source .=$this->expression->format($parser);} $source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){$this->expression->injectScope($parent_scope);}}class IfStmt extends Stmt{public $condition;public $body;public $elif;public $else;public function __construct($condition,$body,$elif,$else){$this->condition=$condition;$this->body=$body;$this->elif=$elif;$this->else=$else;} public function format(Parser $parser){$source='if ';$source .=$this->condition->format($parser);$source .=PHP_EOL;$parser->openScope();$source .=$this->body->format($parser);$parser->closeScope();foreach($this->elif as $elif){$source .=$elif->format($parser);} if(null !==$this->else){$source .=$parser->indent();$source .='else';$source .=PHP_EOL;$parser->openScope();$source .=$this->else->format($parser);$parser->closeScope();} $source .=$parser->indent();$source .='end';$source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){$this->body->scope=new Scope($parent_scope);$this->condition->injectScope($parent_scope);foreach($this->body->stmt_list as $node){$node->injectScope($this->body->scope);}   foreach($this->elif as $elif){$elif->injectScope($parent_scope);}  if(null !==$this->else){$this->else->scope=new Scope($parent_scope);foreach($this->else->stmt_list as $node){$node->injectScope($this->else->scope);}}} public function runTypeChecker(){$condition_type=$this->condition->getType();if(!$condition_type->isBoolean()){throw new TypeError(Localization::message('TYP140',[$condition_type]));} $this->body->runTypeChecker();foreach($this->elif as $elif){$elif->runTypeChecker();} if(null !==$this->else){$this->else->runTypeChecker();}}}class ForeachStmt extends Stmt{public $key;public $alias;public $generator;public $body;public function __construct($key,$alias,$generator,$body){$this->key=$key;$this->alias=$alias;$this->generator=$generator;$this->body=$body;} public function format(Parser $parser){$source='foreach ';if(null !==$this->key){$source .=$this->key;$source .=': ';} $source .=$this->alias;$source .=' in ';$source .=$this->generator->format($parser);$source .=PHP_EOL;$parser->openScope();foreach($this->body as $stmt){$source .=$parser->indent();$source .=$stmt->format($parser);} $parser->closeScope();$source .=$parser->indent();$source .='end';$source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){$this->scope=new Scope($parent_scope);$this->scope->setMetaInContext(Meta::M_LABEL,Meta::nextMetaLabel());if(null !==$this->key){$this->scope->insert($this->key,Kind::K_VARIABLE | Kind::K_INITIALIZED);} if($this->key ===$this->alias){throw new ScopeError(Localization::message('SCO180',[$this->alias]));} $this->scope->insert($this->alias,Kind::K_VARIABLE | Kind::K_INITIALIZED | Kind::K_MUTABLE);$this->generator->injectScope($parent_scope);foreach($this->body as $node){$node->injectScope($this->scope);}} public function runTypeChecker(){$generator_type=$this->generator->getType();if(!$generator_type->isIterable()){throw new TypeError(Localization::message('TYP260',[$generator_type]));} if(null !==$this->key){$key_type=$generator_type instanceof ListType ?new LiteralType(NativeQuackType::T_NUMBER) :$generator_type->key;$this->scope->setMeta(Meta::M_TYPE,$this->key,$key_type);} $value_type=$generator_type instanceof ListType ?$generator_type->type :$generator_type->key;foreach($this->body as $stmt){$stmt->runTypeChecker();}}}class LetStmt extends Stmt{public $name;public $type;public $value;public $mutable;private $scope;public function __construct($name,$type,$value,$mutable){$this->name=$name;$this->type=$type;$this->value=$value;$this->mutable=$mutable;} public function format(Parser $parser){$source='let ';if($this->mutable){$source .='mut ';} $source .=$this->name;if(null !==$this->type){$source .=' :: ' .$this->type;} if(null !==$this->value){$source .=' :- ' .$this->value->format($parser);} $source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){$this->scope=$parent_scope;$mask=Kind::K_VARIABLE |($this->mutable ?Kind::K_MUTABLE :0x0);if(null ===$this->value){$this->scope->insert($this->name,$mask);} else{$this->scope->insert($this->name,$mask | Kind::K_INITIALIZED);$this->value->injectScope($parent_scope);}} public function runTypeChecker(){if(null ===$this->type && null ===$this->value){throw new TypeError(Localization::message('TYP290',[$this->name]));} if($this->mutable){$this->checkMutable();} else{$this->checkImmutable();}} public function checkMutable(){if(null ===$this->value){$this->type->simplify();$this->scope->setMeta(Meta::M_TYPE,$this->name,$this->type);return;}  if(null ===$this->type){$inferred_type=$this->value->getType();$this->scope->setMeta(Meta::M_TYPE,$this->name,$inferred_type);return;}  $this->checkTypeAndValue();} public function checkImmutable(){if(null ===$this->value){throw new TypeError(Localization::message('TYP270',[$this->name .' :: ' .$this->type]));}  if(null ===$this->type){$type=$this->value->getType();$this->scope->setMeta(Meta::M_TYPE,$this->name,$type);return;} $this->checkTypeAndValue();} public function checkTypeAndValue(){$this->scope->setMeta(Meta::M_TYPE,$this->name,$this->type);$inferred_type=$this->value->getType();if(!$this->type->check($inferred_type)){throw new TypeError(Localization::message('TYP300',[ $this->name,$this->type,$inferred_type ]));}}}class SwitchStmt extends Stmt{public $value;public $cases;public function __construct($value,$cases){$this->value=$value;$this->cases=$cases;} public function format(Parser $parser){$source='switch ';$source .=$this->value->format($parser);$source .=PHP_EOL;$parser->openScope();foreach($this->cases as $case){$source .=$parser->indent();$source .=$case->format($parser);} $parser->closeScope();$source .=$parser->indent();$source .='end';$source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){$this->value->injectScope($parent_scope);foreach($this->cases as $case){$case->injectScope($parent_scope);}} public function runTypeChecker(){$value_type=$this->value->getType();$else_counter=0;foreach($this->cases as $case){if(!$case->is_else){$case_type=$case->value->getType();if(!$value_type->check($case_type)){throw new TypeError(Localization::message('TYP150',[$value_type,$case_type]));}} else{$else_counter++;}} if($else_counter > 1){throw new TypeError(Localization::message('TYP160',[]));} foreach($this->cases as $case){$case->runTypeChecker();}}}class ExprStmt extends Stmt{public $expr;public function __construct($expr){$this->expr=$expr;} public function format(Parser $parser){return 'do ' .$this->expr->format($parser) .PHP_EOL;} public function injectScope(&$parent_scope){$this->expr->injectScope($parent_scope);} public function runTypeChecker(){$type=$this->expr->getType();var_dump((string) $type);}}class PostConditionalStmt extends Stmt{public $stmt;public $predicate;public $tag;public function __construct(Stmt $stmt,Expr $predicate,$tag){$this->stmt=$stmt;$this->predicate=$predicate;$this->tag=$tag;} public function format(Parser $parser){$source=rtrim($this->stmt->format($parser),PHP_EOL);$source .=Tag::T_WHEN ===$this->tag ?' when ' :' unless ';$source .=$this->predicate->format($parser);$source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){$this->scope=new Scope($parent_scope);$this->predicate->injectScope($parent_scope);$this->stmt->injectScope($this->scope);} public function runTypeChecker(){$condition_type=$this->predicate->getType();if(!$condition_type->isBoolean()){throw new TypeError(Localization::message('TYP030',[$condition_type]));}}}class CaseStmt extends Stmt{public $value;public $body;public $is_else;public function __construct($value,$body,$is_else=false){$this->value=$value;$this->body=$body;$this->is_else=$is_else;} public function format(Parser $parser){$source=$this->is_else ?'else' :'case ' .$this->value->format($parser);$source .=PHP_EOL;$parser->openScope();$source .=$this->body->format($parser);$parser->closeScope();return $source;} public function injectScope(&$parent_scope){$this->scope=new Scope($parent_scope);if(!$this->is_else){$this->value->injectScope($parent_scope);} foreach($this->body->stmt_list as $node){$node->injectScope($this->scope);}} public function runTypeChecker(){$this->body->runTypeChecker();}}class FnSignatureStmt extends Stmt{public $name;public $parameters;public $type;public function __construct($name,$parameters,$type){$this->name=$name;$this->parameters=$parameters;$this->type=$type;} public function format(Parser $parser){$source=$this->name .'(';$source .=implode(', ',array_map(function($param){$parameter=$param->name;if(null !==$param->type){$parameter .=' :: ' .$param->type;} return $parameter;},$this->parameters));$source .=')';if(!is_null($this->type)){$source .=' -> ' .$this->type;} return $source;} public function injectScope(&$parent_scope){foreach($this->parameters as $param){if($parent_scope->hasLocal($param->name)){throw new ScopeError(Localization::message('SCO060',[$param->name,$this->name]));}  $parent_scope->insert($param->name,Kind::K_INITIALIZED | Kind::K_MUTABLE | Kind::K_VARIABLE | Kind::K_PARAMETER);}} public function getParametersTypes(){return array_map(function($parameter){return null ===$parameter->type ?new GenericType(Meta::nextGenericVarName()) :$parameter->type;},$this->parameters);} public function runTypeChecker(){}}class WhileStmt extends Stmt{public $condition;public $body;public function __construct($condition,$body){$this->condition=$condition;$this->body=$body;} public function format(Parser $parser){$source='while ';$source .=$this->condition->format($parser);$source .=PHP_EOL;$parser->openScope();foreach($this->body as $stmt){$source .=$parser->indent();$source .=$stmt->format($parser);} $parser->closeScope();$source .=$parser->indent();$source .='end' .PHP_EOL;return $source;} public function injectScope(&$parent_scope){$this->scope=new Scope($parent_scope);$this->scope->setMetaInContext(Meta::M_LABEL,Meta::nextMetaLabel());$this->condition->injectScope($parent_scope);foreach($this->body as $node){$node->injectScope($this->scope);}} public function runTypeChecker(){$condition_type=$this->condition->getType();if(!$condition_type->isBoolean()){throw new TypeError(Localization::message('TYP010',[$condition_type]));} foreach($this->body as $node){$node->runTypeChecker();}}}class LabelStmt extends Stmt{public $name;public $stmt;public function __construct($name,$stmt){$this->name=$name;$this->stmt=$stmt;} public function format(Parser $parser){$source='[' .$this->name .']';$source .=PHP_EOL;$source .=$parser->indent();$source .=$this->stmt->format($parser);return $source;} public function injectScope(&$parent_scope){$this->scope=new Scope($parent_scope);$this->scope->insert($this->name,Kind::K_LABEL);$this->stmt->injectScope($this->scope);} public function runTypeChecker(){$this->stmt->runTypeChecker();}}class ProgramStmt extends Stmt{public $stmt_list;public function __construct($stmt_list){$this->stmt_list=$stmt_list;} public function format(Parser $parser){$source='';foreach($this->stmt_list as $stmt){$source .=$stmt->format($parser);} return $source;} public function injectScope(&$parent_scope){$this->scope=new Scope($parent_scope);foreach($this->stmt_list as $node){$node->injectScope($this->scope);}} public function runTypeChecker(){foreach($this->stmt_list as $node){$node->runTypeChecker();}} public function attachValidAST($ast){$safe_scope=clone $this->scope;try{foreach($ast->stmt_list as $node){$node->injectScope($this->scope);} foreach($ast->stmt_list as $node){$node->runTypeChecker();} $this->stmt_list=array_merge($this->stmt_list,$ast->stmt_list);} catch(\Exception $e){$this->scope=$safe_scope;throw $e;}}}class ContinueStmt extends Stmt{public $label;public $is_explicit;public function __construct($label=null){$this->label=$label;$this->is_explicit=null !==$label;} public function format(Parser $parser){$source='continue';if($this->is_explicit){$source .=' ';$source .=$this->label;} $source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){if(!$this->is_explicit){$label=$parent_scope->getMetaInContext(Meta::M_LABEL);if(null ===$label){throw new ScopeError(Localization::message('SCO140',['continue']));}} else{$meta_label=$parent_scope->getMetaInContext(Meta::M_LABEL);if(null ===$meta_label){throw new ScopeError(Localization::message('SCO140',['continue']));} $label=$parent_scope->lookup($this->label);if(null ===$label){throw new ScopeError(Localization::message('SCO150',['continue',$this->label]));}  if(~$label & Kind::K_LABEL){throw new ScopeError(Localization::message('SCO160',['continue',$this->label]));} $refcount=$parent_scope->getMeta(Meta::M_REF_COUNT,$this->label);if(null ===$refcount){$parent_scope->setMeta(Meta::M_REF_COUNT,$this->label,1);} else{$parent_scope->setMeta(Meta::M_REF_COUNT,$this->label,$refcount + 1);}}} public function runTypeChecker(){}}class BlockStmt extends Stmt{public $stmt_list;public function __construct($stmt_list){$this->stmt_list=$stmt_list;} public function format(Parser $parser){$source='begin';$source .=PHP_EOL;$parser->openScope();foreach($this->stmt_list as $stmt){$source .=$parser->indent();$source .=$stmt->format($parser);} $parser->closeScope();$source .=$parser->indent();$source .='end';$source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){$this->scope=new Scope($parent_scope);foreach($this->stmt_list as $node){$node->injectScope($this->scope);}} public function runTypeChecker(){foreach($this->stmt_list as $stmt){$stmt->runTypeChecker();}}}class ForStmt extends Stmt{public $variable;public $from;public $to;public $by;public $body;public function __construct($variable,$from,$to,$by,$body){$this->variable=$variable;$this->from=$from;$this->to=$to;$this->by=$by;$this->body=$body;} public function format(Parser $parser){$source='for ';$source .=$this->variable;$source .=' from ';$source .=$this->from->format($parser);$source .=' to ';$source .=$this->to->format($parser);if(null !==$this->by){$source .=' by ';$source .=$this->by->format($parser);} $source .=PHP_EOL;$parser->openScope();$source .=$this->body->format($parser);$parser->closeScope();$source .=$parser->indent();$source .='end';$source .=PHP_EOL;return $source;} public function injectScope(&$parent_scope){$this->scope=new Scope($parent_scope);$this->scope->setMetaInContext(Meta::M_LABEL,Meta::nextMetaLabel());$this->scope->insert($this->variable,Kind::K_VARIABLE | Kind::K_MUTABLE | Kind::K_INITIALIZED);$this->from->injectScope($parent_scope);$this->to->injectScope($parent_scope);if(null !==$this->by){$this->by->injectScope($parent_scope);} foreach($this->body->stmt_list as $node){$node->injectScope($this->scope);}} public function runTypeChecker(){$keys=['from','to'];if(null !==$this->by){$keys[]='by';} foreach($keys as $key){$type=$this->{$key}->getType();if(!$type->isNumber()){throw new TypeError(Localization::message('TYP170',[$key,$type]));}} $this->scope->setMeta(Meta::M_TYPE,$this->variable,new LiteralType(NativeQuackType::T_NUMBER));$this->body->runTypeChecker();}}class ElifStmt extends Stmt{public $condition;public $body;public function __construct($condition,$body){$this->condition=$condition;$this->body=$body;} public function format(Parser $parser){$source=$parser->indent();$source .='elif ';$source .=$this->condition->format($parser);$source .=PHP_EOL;$parser->openScope();foreach($this->body as $stmt){$source .=$parser->indent();$source .=$stmt->format($parser);} $parser->closeScope();return $source;} public function injectScope(&$parent_scope){$this->scope=new Scope($parent_scope);$this->condition->injectScope($parent_scope);foreach($this->body as $node){$node->injectScope($this->scope);}} public function runTypeChecker(){$condition_type=$this->condition->getType();if(!$condition_type->isBoolean()){throw new TypeError(Localization::message('TYP180',[$condition_type]));} foreach($this->body as $stmt){$stmt->runTypeChecker();}}}} namespace QuackCompiler\Ast\Types{ use \QuackCompiler\Types\NativeQuackType;use \QuackCompiler\Intl\Localization;use \QuackCompiler\Types\TypeError;abstract class TypeNode{protected $parentheses_level=0;public function addParentheses(){$this->parentheses_level++;} public function removeParentheses(){$this->parentheses_level--;} protected function parenthesize($source){$level=$this->parentheses_level;return str_repeat('(',$level) .$source .str_repeat(')',$level);} public function isAtom($atom){return $this instanceof AtomType && $this->name ===$atom;} public function isNumber(){return $this instanceof LiteralType && NativeQuackType::T_NUMBER ===$this->code;} public function isString(){return $this instanceof LiteralType && NativeQuackType::T_STR ===$this->code;} public function isBoolean(){return $this instanceof LiteralType && NativeQuackType::T_BOOL ===$this->code;} public function isRegex(){return $this instanceof LiteralType && NativeQuackType::T_REGEX ===$this->code;} public function isIterable(){return $this instanceof MapType || $this instanceof ListType;} public function simplify(){return $this;} abstract function check(TypeNode $other);}class InstanceType extends TypeNode{public $qualified_name;public function __construct($qualified_name){$this->qualified_name=$qualified_name;} public function __toString(){return $this->parenthesize('%' .join('.',$this->qualified_name));} public function check(TypeNode $other){return false;}}class FunctionType extends TypeNode{public $parameters;public $return;public function __construct($parameters,$return){$this->parameters=$parameters;$this->return=$return;} public function __toString(){return $this->parenthesize( '&[' .join(', ',$this->parameters) .'] -> ' .$this->return );} public function check(TypeNode $other){$message=Localization::message('TYP350',[$this,$other]);if(!($other instanceof FunctionType)){return false;}  $self_arity=sizeof($this->parameters);$other_arity=sizeof($other->parameters);if($self_arity !==$other_arity){$message .='     > ' .Localization::message('TYP360',[$self_arity,$other_arity]);throw new TypeError($message);}  for($i=0;$i < $self_arity;$i++){$self_type=$this->parameters[$i];$other_type=$other->parameters[$i];if(!$self_type->check($other_type)){$message .='     > ' .Localization::message('TYP370',[$i + 1,$self_type,$other_type]);throw new TypeError($message);}}  if(!$this->return->check($other->return)){$message .='     > ' .Localization::message('TYP380',[$this->return,$other->return]);throw new TypeError($message);} return true;}}class ListType extends TypeNode{public $type;public function __construct(TypeNode $type){$this->type=$type;} public function __toString(){return $this->parenthesize('{' .$this->type .'}');} public function check(TypeNode $other){if(!($other instanceof ListType)){return false;} return $this->type->check($other->type);}}class MapType extends TypeNode{public $key;public $value;public function __construct(TypeNode $key,TypeNode $value){$this->key=$key;$this->value=$value;} public function __toString(){return $this->parenthesize( '#{' .$this->key .': ' .$this->value .'}' );} public function check(TypeNode $other){if(!($other instanceof MapType)){return false;} $match_keys=$this->key->check($other->key);$match_values=$this->value->check($other->value);if(!$match_keys || !$match_values){$message=Localization::message('TYP350',[$this,$other]);if(!$match_keys){$message .='     > ' .Localization::message('TYP340',['key',$this->key,$other->key]);} if(!$match_values){$message .=PHP_EOL .'     > ' .Localization::message('TYP340',['value',$this->value,$other->value]);} throw new TypeError($message);} return true;}}class ObjectType extends TypeNode{public $properties;public function __construct($properties){$this->properties=$properties;} public function __toString(){$source='%{';$source .=implode(', ',array_map(function($name){return "{$name}: {$this->properties[$name]}";},array_keys($this->properties)));$source .='}';return $this->parenthesize($source);} public function check(TypeNode $other){if(!($other instanceof ObjectType)){return false;}  $different_properties=array_diff_key($this->properties,$other->properties);if(sizeof($different_properties) > 0){return false;}  foreach(array_keys($this->properties) as $property){if(!$this->properties[$property]->check($other->properties[$property])){return false;}} return true;}}class LiteralType extends TypeNode{public $code;public function __construct($code){$this->code=$code;} public function __toString(){$map=[ NativeQuackType::T_STR => 'string',NativeQuackType::T_NUMBER => 'number',NativeQuackType::T_BOOL => 'boolean',NativeQuackType::T_REGEX => 'regex',NativeQuackType::T_BLOCK => 'block',NativeQuackType::T_UNIT => 'unit',NativeQuackType::T_NIL => 'nil',NativeQuackType::T_BYTE => 'byte',NativeQuackType::T_ATOM => 'atom' ];return $this->parenthesize( array_key_exists($this->code,$map) ?$map[$this->code] :'unknown' );} public function check(TypeNode $other){if(!($other instanceof LiteralType)){return $other instanceof AtomType && NativeQuackType::T_ATOM ===$this->code;} return $this->code ===$other->code;}}class AtomType extends TypeNode{public $name;public function __construct($name){$this->name=$name;} public function __toString(){return $this->parenthesize($this->name);} public function check(TypeNode $other){if(!($other instanceof AtomType)){return false;} return $this->name ===$other->name;}}class GenericType extends TypeNode{public $name;public function __construct($name){$this->name=$name;} public function __toString(){return $this->parenthesize($this->name);} public function check(TypeNode $other){return false;}}class TupleType extends TypeNode{public $types;public $size;public function __construct(...$types){$this->types=$types;$this->size=sizeof($types);} public function __toString(){return $this->parenthesize('#(' .implode(', ',$this->types) .')');} public function check(TypeNode $other){return false;}}class OperatorType extends TypeNode{public $operator;public $left;public $right;public function __construct($left,$operator,$right){$this->left=$left;$this->operator=$operator;$this->right=$right;} public function __toString(){return $this->parenthesize( $this->left ." {$this->operator} " .$this->right );} public function simplify(){if('&' !==$this->operator){return $this;} $simple_left=$this->left->simplify();$simple_right=$this->right->simplify();if($simple_left instanceof ObjectType && $simple_right instanceof ObjectType){$properties=[];foreach($simple_left->properties as $name => $type){$properties[$name]=$type;} foreach($simple_right->properties as $name => $type){if(array_key_exists($name,$properties)){if(!$properties[$name]->check($type)){throw new TypeError(Localization::message('TYP400',[$this->left,$this->right,$name,$properties[$name],$type]));}} else{$properties[$name]=$type;}} return new ObjectType($properties);} throw new TypeError(Localization::message('TYP390',[$this->left,$this->right]));} public function check(TypeNode $other){return $this->simplify()->check($other);}}} namespace QuackCompiler\Scope{ use \QuackCompiler\Intl\Localization;use \QuackCompiler\Scope\Meta;use \Exception;interface Membered{public function getMembers();}class Scope{public $table=[];public $parent;public $meta=[];public function __construct(Scope $parent=null){$this->parent=$parent;} public function hasLocal($symbol){return array_key_exists($symbol,$this->table);} public function insert($symbol,$value){if($this->hasLocal($symbol)){throw new ScopeError(Localization::message('SCO130',[$symbol]));} $this->table[$symbol]=$value;} public function lookup($symbol){if($this->hasLocal($symbol)){return $this->table[$symbol];} return null !==$this->parent ?$this->parent->lookup($symbol) :null;} public function setMeta($property,$symbol,$value){$scope=$this->getSymbolScope($symbol);if(!array_key_exists($symbol,$scope->meta)){$scope->meta[$symbol]=[];} $scope->meta[$symbol][$property]=$value;} public function setMetaInContext($property,$value){$this->meta[$property]=$value;} public function getMeta($property,$symbol){$scope=$this->getSymbolScope($symbol);if(null ===$scope || !array_key_exists($symbol,$scope->meta)){return null;} return array_key_exists($property,$scope->meta[$symbol]) ?$scope->meta[$symbol][$property] :null;} public function getMetaInContext($property){if(array_key_exists($property,$this->meta)){return $this->meta[$property];} return null !==$this->parent ?$this->parent->getMetaInContext($property) :null;} public function getSymbolScope($symbol){if($this->hasLocal($symbol)){return $this;} return null !==$this->parent ?$this->parent->getSymbolScope($symbol) :null;}}class Meta{const M_REF_COUNT='refcount';const M_TYPE='type';const M_LABEL='label';private static $label_num=0;private static $generic_num=0;public static function nextMetaLabel(){return 'LB' .static::$label_num++;} public static function nextGenericVarName(){return 'A' .static::$generic_num++;}}class Kind{const K_FUNCTION=1 << 0;const K_VARIABLE=1 << 1;const K_CLASS=1 << 4;const K_ENUM=1 << 5;const K_MUTABLE=1 << 6;const K_PARAMETER=1 << 7;const K_LABEL=1 << 8;const K_SPECIAL=1 << 9;const K_MEMBER=1 << 10;const K_INITIALIZED=1 << 11;}class ScopeError extends Exception{protected $message;public function __construct($message){$this->message=$message;} public function __toString(){return join([ BEGIN_RED,"*** Quack, there is a ",BEGIN_GREEN,"semantic",END_GREEN,BEGIN_RED," issue, friend!",PHP_EOL,"    ",$this->message,PHP_EOL,END_RED ]);}}} namespace QuackCompiler\Types{ use \Exception;class TypeError extends Exception{protected $message;public function __construct($message){$this->message=$message;} public function __toString(){return join([ BEGIN_RED,'**** Quack, I\'ve found a ',BEGIN_GREEN,'type error',END_GREEN,BEGIN_RED,', my dear!',PHP_EOL,'     ',$this->message,PHP_EOL,END_RED ]);}}class NativeQuackType{const T_STR=0;const T_NUMBER=2;const T_BOOL=3;const T_OBJ=4;const T_MAP=5;const T_LIST=6;const T_ATOM=9;const T_REGEX=10;const T_LAZY=11;const T_BLOCK=12;const T_ENUM=13;const T_UNIT=14;const T_BYTE=15;const T_NIL=16;}} namespace Main{ use \QuackCompiler\Lexer\Tokenizer;use \QuackCompiler\Parser\EOFError;use \QuackCompiler\Parser\TokenReader;use \QuackCompiler\Scope\Scope;define('BASE_PATH',__DIR__ .'/..');if(!extension_loaded('readline')){echo "Missing readline extension on PHP. Recompile with --with-readline";exit;} function isPOSIX(){static $value;if(null ===$value){$value=strtoupper(substr(PHP_OS,0,3)) !=='WIN';} return $value;} function session(){static $session;if(null ===$session){$session=(object) [ 'command' => '','complete_stmt' => true,'program_ast' => null ];} return $session;} function start_repl(){$dot=isPOSIX() ?'·' :'-';echo "Quack {$dot} Copyright (C) 2016 Marcelo Camargo
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions; type 'show c' for details.\n
";echo "Use quack --help for more information",PHP_EOL;if(args_have('-h','--help')){open_repl_help();return;} repl();} function quack(){if(isPOSIX()){$wav=realpath(dirname(__FILE__) .'/../../resource/quack.wav');$player="afplay";if(`which aplay`){$player="aplay";} exec("$player $wav > /dev/null 2> /dev/null &");}} function install_stream_handler(){$prompt=session()->complete_stmt ?"Quack> " :"\__(\"> ";if(isPOSIX()){begin_yellow();readline_callback_handler_install($prompt,__NAMESPACE__ .'\\readline_callback');end_yellow();} else{echo "$prompt";}} function begin_yellow(){echo "\033[01;33m";} function end_yellow(){echo "\033[0m";} function print_entire_license(){echo file_get_contents(__DIR__ ."/../../LICENSE.md");} function readline_callback($command){$session=session();$command=trim($command);switch(trim($command)){case ':quit':case ':q':exit;case 'show c':print_entire_license();goto next;case '':goto next;case ':clear':$clear=isPOSIX() ?'clear' :'cls';system($clear);goto next;} $run_command=$session->complete_stmt ?$command :$session->command .' ' .$command;$lexer=new Tokenizer($run_command);$parser=new TokenReader($lexer);try{$parser->parse();if(null ===$session->program_ast){$global_scope=new Scope();$parser->ast->injectScope($global_scope);$parser->ast->runTypeChecker();$session->program_ast=$parser->ast;} else{$session->program_ast->attachValidAST($parser->ast);} $session->complete_stmt=true;args_have('-f','--format') && $parser->format();} catch(EOFError $e){$session->command=$run_command;$session->complete_stmt=false;} catch(\Exception $e){$session->command='';$session->complete_stmt=true;echo $e;if(!args_have('--shut-up-duck')){quack();}} next:if(isPOSIX()){if('' ===$command){readline_on_new_line();} else{readline_add_history($command);}} install_stream_handler();} function repl(){$title="Quack interactive mode";if(isPOSIX()){fwrite(STDOUT,"\x1b]2;{$title}\x07");} else{`title {$title}`;} echo "Type ^C or :quit to leave",PHP_EOL;install_stream_handler();while(true){if(isPOSIX()){$write=null;$except=null;$stream=@stream_select($read=[STDIN],$write,$except,null);if($stream && in_array(STDIN,$read)){readline_callback_read_char();}} else{$line=stream_get_line(STDIN,1024,PHP_EOL);readline_callback($line);}}} function open_repl_help(){} function args_have(){global $argv;return count(array_intersect($argv,func_get_args())) > 0;} start_repl();}